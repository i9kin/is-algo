<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>is-algo</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
                <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="judje.html"><strong aria-hidden="true">1.1.</strong> Тестирующая система</a></li><li class="chapter-item expanded "><a href="how-to-read.html"><strong aria-hidden="true">1.2.</strong> Как читать</a></li><li class="chapter-item expanded "><a href="how-to-solve.html"><strong aria-hidden="true">1.3.</strong> Как придумывать</a></li><li class="chapter-item expanded "><a href="how-to-testing.html"><strong aria-hidden="true">1.4.</strong> Как тестировать</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Начало работы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.1.</strong> Установка</a></li><li class="chapter-item expanded "><a href="code-editor.html"><strong aria-hidden="true">2.2.</strong> Редактор кода</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">2.3.</strong> Решение задачи</a></li></ol></li><li class="chapter-item expanded "><a href="cpp_base.html"><strong aria-hidden="true">3.</strong> Основы языка C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="data-types.html"><strong aria-hidden="true">3.1.</strong> Типы данных</a></li><li class="chapter-item expanded "><a href="io.html"><strong aria-hidden="true">3.2.</strong> Ввод и вывод</a></li><li class="chapter-item expanded "><a href="branching.html"><strong aria-hidden="true">3.3.</strong> Ветвление</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">3.4.</strong> Циклы</a></li><li class="chapter-item expanded "><a href="array.html"><strong aria-hidden="true">3.5.</strong> Массивы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static-array.html"><strong aria-hidden="true">3.5.1.</strong> Статические массивы</a></li><li class="chapter-item expanded "><a href="dynamic-array.html"><strong aria-hidden="true">3.5.2.</strong> Динамические массивы</a></li><li class="chapter-item expanded "><a href="VLA.html"><strong aria-hidden="true">3.5.3.</strong> VLA</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">3.5.4.</strong> std::vector</a></li><li class="chapter-item expanded "><a href="compare-arrays.html"><strong aria-hidden="true">3.5.5.</strong> Что выбрать?</a></li></ol></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">3.6.</strong> Функции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="params-to-func.html"><strong aria-hidden="true">3.6.1.</strong> Передача параметров в функцию</a></li></ol></li><li class="chapter-item expanded "><a href="links-and-pointers.html"><strong aria-hidden="true">3.7.</strong> Ссылки и указатели</a></li></ol></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">4.</strong> Память</a></li><li class="chapter-item expanded "><a href="greedy/index.html"><strong aria-hidden="true">5.</strong> Жадные алгоритмы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="greedy/intro.html"><strong aria-hidden="true">5.1.</strong> Введение</a></li></ol></li><li class="chapter-item expanded "><a href="asymptotics.html"><strong aria-hidden="true">6.</strong> Асимптотика</a></li><li class="chapter-item expanded "><a href="sorts.html"><strong aria-hidden="true">7.</strong> Сортировки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bubble-sort.html"><strong aria-hidden="true">7.1.</strong> &quot;Пузырьковая&quot; сортировка</a></li><li class="chapter-item expanded "><a href="insertion-sort.html"><strong aria-hidden="true">7.2.</strong> Сортировка вставкой</a></li><li class="chapter-item expanded "><a href="selection-sort.html"><strong aria-hidden="true">7.3.</strong> &quot;Выборочная&quot; сортировка</a></li><li class="chapter-item expanded "><a href="merge-sort.html"><strong aria-hidden="true">7.4.</strong> Сортировка слиянием</a></li><li class="chapter-item expanded "><a href="quick-sort.html"><strong aria-hidden="true">7.5.</strong> Быстрая сортировка</a></li></ol></li><li class="chapter-item expanded "><a href="tasks/index.html"><strong aria-hidden="true">8.</strong> Решаем задачи</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tasks/different-odd.html"><strong aria-hidden="true">8.1.</strong> Другая чётность</a></li><li class="chapter-item expanded "><a href="tasks/sum-of-factorials.html"><strong aria-hidden="true">8.2.</strong> Сумма факториалов</a></li><li class="chapter-item expanded "><a href="tasks/longest-easy.html"><strong aria-hidden="true">8.3.</strong> Наибольший отрезок</a></li></ol></li><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">9.</strong> Память</a></li><li class="chapter-item expanded "><a href="CONTRIBUTING.html"><strong aria-hidden="true">10.</strong> Сделайте вклад</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">is-algo</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/9kin/is-algo/tree/master/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Главная-страница"><a class="header" href="#Главная-страница">Главная страница</a></h1>
<p><a href="https://t.me/+uunjZQSTJ0hhNjFi">Ссылка на тг канал</a> Нас уже 142!</p>
<p>Пройдите важный <a href="https://t.me/c/1718888756/13">опрос</a> и зайдите в чат канала.</p>
<p>Я — <a href="https://t.me/i9kin">tg@i9kin</a> по поводу замечаний и предложений.
С фидбэком и предложениями также пишите <a href="https://t.me/chainbrain">tg@chainbrain</a>, <a href="https://t.me/Kiksnol">tg@kiksnol</a>.</p>
<h1 id="Список-полезных-ресурсов"><a class="header" href="#Список-полезных-ресурсов">Список полезных ресурсов</a></h1>
<ul>
<li><a href="https://codeforces.com">codeforces.com</a> - сайт, чтобы попрактиковаться в решении задач и/или поучаствовать в соревнованиях</li>
</ul>
<p>Сайты со статьями по алгоритмам:</p>
<ul>
<li><a href="https://ru.algorithmica.org">alorithmika</a> - статьи на русском по дефолт алгоритмам и структурам</li>
<li><a href="https://cp-algorithms.com">cp-algorithms</a> - топ англоязычный сайт по продвинутым алгоритмам </li>
<li><a href="http://e-maxx.ru/algo/">e-maxx</a> - то же самое, что и линк выше, но на русском</li>
</ul>
<p>Справочники по плюсам:</p>
<ul>
<li><a href="https://en.cppreference.com/w/">cppreference.com</a> - справочник по C++ на английском.</li>
<li><a href="https://metanit.com/cpp/tutorial/">metanit.com</a> - более подробные гайды по C++ на русском</li>
</ul>
<p>Ютуб:</p>
<ul>
<li><a href="https://www.youtube.com/@pavelmavrin">Pavel_Mavrin</a> - лекции по алгоритмам преподавателя КТ</li>
</ul>
<p>Книги:</p>
<ul>
<li><a href="https://vk.com/doc191450968_561608466?hash=1K1Cd8tP7N8rZcYeFS8pSJjr82ROC22zM2WlzBbBBzz&amp;dl=RolI6VzGuZKU7zeJEYpjawEP7lZ0yWFsnsqwcJOzkIP">Cormen_Book</a> - книга Томаса Кормена по алгоритмам</li>
<li><a href="http://lib.jizpi.uz/pluginfile.php/7322/mod_resource/content/0/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE_%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%A1%2B%2B_%D0%A0_%D0%9B%D0%B0%D1%84%D0%BE%D1%80%D0%B5.pdf">Lafore_Book</a> - книга по ООП на C++, которая помогает глубже вникнуть в язык, понять его особенности и возможности</li>
<li><a href="https://library.samdu.uz/files/e946919660708044a522983e0741690c_%D0%9B%D0%B0%D0%B0%D0%BA%D1%81%D0%BE%D0%BD%D0%B5%D0%BD_%D0%90_%D0%9E%D0%BB%D0%B8%D0%BC%D0%BF%D0%B8%D0%B0%D0%B4%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5.pdf">Laaksonen_Book</a> - книга по спортивному программированию и алгоритмам.</li>
</ul>
<h1 id="Помощь"><a class="header" href="#Помощь">Помощь</a></h1>
<p>Будем признательны за любой вклад.</p>
<p>Подробнее прочтите в <a href="./CONTRIBUTING.html">этой</a> главе.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Тестирующая-система"><a class="header" href="#Тестирующая-система">Тестирующая система</a></h1>
<p>Перед решением задачи, стоит разобраться с тестирующей системой)</p>
<p>Раз и навсегда разберёмся с ответом на вопрос &quot;почему у меня задача не заходит!?&quot;.</p>
<p>На курсе &quot;алгоритмы и структуры данных&quot; будет использоваться <a href="https://sort-me.org">sort-me</a> — система для автоматического тестирования решений.</p>
<p>Когда вы отправляете код на тестирование в систему, ваше решение запускается в специальном безопасном окружение (sandbox) и последовательно тестируется на заранее приготовленных тестах жюри. В результате вы получаете вердикты, смысл которых понятен из названия.</p>
<h1 id="вердикты-тестирования"><a class="header" href="#вердикты-тестирования">вердикты тестирования</a></h1>
<ol>
<li>
<p>Полное решение (<code>AC</code>). Решение успешно прошло все тесты!</p>
</li>
<li>
<p>Неправильный ответ (<code>WA</code>). Решение на тесте X дало неверный ответ. </p>
</li>
<li>
<p>Неверный формат ответа (<code>PE</code>). Решение на тесте X вывело ответ в некорректном формате. </p>
</li>
<li>
<p>Ошибка при выполнении (<code>RE</code>). Решение на тесте X <code>упало</code>.</p>
</li>
<li>
<p>Превышено время работы (<code>TL</code>). Решение на тесте X работает больше по времени чем по условию.</p>
</li>
<li>
<p>Превышен лимит по памяти (<code>ML</code>). Решение на тесте X заняло больше памяти чем по условию.</p>
</li>
</ol>
<p>Вердикт <code>RE</code> может происходить из-за многих проблем связанных с вашим кодом — неверная запись в память, деление на 0. Собственно всё что возвращает код программы отличный от 0.</p>
<p>Если решение выходит за установленный лимит по памяти (<code>ML</code>) или по времени (<code>TL</code>) во время тестирования, то sandbox моментально убивает ваше решение (процесс решения).</p>
<p>Вердикты <code>WA</code> и <code>PE</code> получаются только после корректной работы вашей программы, но в вашем ответе содержится ошибка. Собственно тестирующая система запускает <code>чекер</code> (программу которая берёт тест, ответ жюри и ваш ответ и пытается проверить). Если вы выводили не по <code>формату выходных данных</code> то у вас возможно будет <code>PE</code>, так как чекер просто сломается (<code>RE</code>, но для чекера). Если вы вывели ответ который <code>не верный</code>, то вы получаете <code>WA</code>. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-читать"><a class="header" href="#Как-читать">Как читать</a></h1>
<p>Перед решением задачи, её стоит прочитать)</p>
<h1 id="Структура-условия"><a class="header" href="#Структура-условия">Структура условия</a></h1>
<p>Условие задачи состоит из 4 важных блоков :</p>
<ol>
<li>
<p>Формулировка задачи. Тут описана чуть ли не вся задача.</p>
</li>
<li>
<p>Входные данные. Формат по которому стоит интерпретировать входные данные. Какие ограничения существуют.</p>
</li>
<li>
<p>Выходные данные. Формат по которому стоит вывести ответ на тест. Если его не соблюсти, то вы получите или <code>WA</code> или <code>RE</code>.</p>
</li>
<li>
<p>Примеры тестов. Содержит таблицу с тестами. Сначала входные данные (<code>stdin</code>), а потом выходные (<code>stdout</code>).</p>
</li>
<li>
<p>(*) Примечание. Содержит объяснение к тестам из примеров или уточнение условия.</p>
</li>
</ol>
<h1 id="Из-условия-в-модель"><a class="header" href="#Из-условия-в-модель">Из условия в модель</a></h1>
<p>Советую читать условие полностью, часто подсматривая на тесты и ограничения на входные данные. Вы должны отбросить ненужное и оставить <code>самое нужное</code>. Надо построить в голове некоторую модель, это придёт с опытом решения задач.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-придумывать"><a class="header" href="#Как-придумывать">Как придумывать</a></h1>
<p>Чтобы придумать алгоритм, который решит задачу, не существует точной последовательности действий.</p>
<p>НО, я бы выделил такие шаги :</p>
<ol>
<li>Задать себе вопрос — &quot;на какую тему лаба?&quot;. Не стоит придумывать решение используя темы, которые по плану ещё не проходили (или не пройдёте), так как на них не могли дать задачу) (наверное?) Скорее всего задачи будут только на тему лабы, и лишь вспомогательно использовать темы предыдущие.</li>
<li>Из 1-го пункта следует, что вы должны перебрать алгоритмы лабы в голове. На самом деле, вы лишь должны <code>нащупать</code> тот самый алгоритм.</li>
<li>Проверить, а как ваша модель решается алгоритмом. Иногда, требуется добавить некоторую обработку, чтобы <code>свести</code> вашу модель в другую, которую проще решать. </li>
<li>Подумать, как ваш алгоритм будет вести на разных тестах.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-тестировать"><a class="header" href="#Как-тестировать">Как тестировать</a></h1>
<blockquote>
<p>Как понять, что алгоритм, который ты придумал — не работает для всех случаев?</p>
</blockquote>
<p>Нужно построить контрпример. Можно это делать ручками перебирая различные тесты, а можно автоматически.</p>
<h1 id="Автоматическое-нахождение-контрпримера"><a class="header" href="#Автоматическое-нахождение-контрпримера">Автоматическое нахождение контрпримера</a></h1>
<p>Cтресс-тестирование — это метод, с помощью которого мы можем запустить наше решение (которое, не правильное) на случайных тестах и сопоставить его результат с вывод решения, которое является решением грубой силы (скорее всего медленное, но точно правильное).</p>
<p>Правильность медленного решения можно проверить, отослав код и получив <code>TL</code>.</p>
<p>Что надо :</p>
<ul>
<li>Решение, которое мы хотим протестировать.</li>
<li>Решение методом грубой силы, которое даёт <code>правильные ответы</code>.</li>
<li>Генератор для генерации тестовых примеров, которые соответствуют задачи.</li>
</ul>
<p>Принцип работы: </p>
<ol>
<li>Генерировать случайный тест. Лучше его записать в файл.</li>
<li>Запустить решение, которое даёт правильный ответ.</li>
<li>Запустить решение, которое неправильное.</li>
<li>Сравнить результаты вывода двух решений. Скорее всего просто на равенство строк, но иногда <code>чекер</code> может быть сложнее.</li>
</ol>
<p>Можно всё сделать в одном файле, но это менее удобнее.</p>
<h1 id="Написание-скрипта"><a class="header" href="#Написание-скрипта">Написание скрипта</a></h1>
<ol>
<li>Напишите генератор теста и проверку ответов двух решений в одном файле.</li>
<li>Лучше использовать <code>python</code>/<code>bash</code>. Получается очень кратко и быстро писать.</li>
<li>Используйте <code>seed</code> для генератора. Чтобы при перезапуске стресс-теста проверять предыдущие тесты. </li>
</ol>
<p><a href="https://pastebin.com/cRGvAuPJ">Вот простой пример</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Начало-работы"><a class="header" href="#Начало-работы">Начало работы</a></h1>
<p>Нам предстоит многому научиться, но любое путешествие начинается с чего-то. В этой главе мы обсудим:</p>
<ul>
<li>Как установить компилятор <code>c++</code></li>
<li>Выбор редактора кода</li>
<li>Первая задача</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Установка"><a class="header" href="#Установка">Установка</a></h1>
<p>Проще всего написать в гугле запрос по типу <code>how to install c++ on ВашаСистема</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Редактор-кода"><a class="header" href="#Редактор-кода">Редактор кода</a></h1>
<p>Пользуйтесь любым редактором кода. </p>
<p>Рекомендуем использовать IDE (Integrated Development Environment) : </p>
<ul>
<li><a href="https://www.jetbrains.com/ru-ru/clion/">clion</a>. Если вы студент, то можно оформить студенческую лицензию.</li>
<li><a href="https://www.codeblocks.org/">code::blocks</a> — бесплатная кроссплатформенная среда разработки.</li>
<li><a href="https://visualstudio.microsoft.com/">Visual Studio</a> — бесплатная (comunity edition версия) среда разработки для windows.</li>
</ul>
<p>Или удобные бесплатные тестовые редакторы (все они имеют расширения под <code>c++</code>) : </p>
<ul>
<li><a href="https://code.visualstudio.com/">visual studio code</a> </li>
<li><a href="https://www.sublimetext.com/">sublime text</a></li>
<li><a href="https://github.com/vim/vim">vim</a></li>
<li><a href="https://www.gnu.org/software/emacs/">emacs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Примеры-решения-задач"><a class="header" href="#Примеры-решения-задач">Примеры решения задач</a></h1>
<p>Решим задачу. Прочтите условие задачи по <a href="https://codeforces.com/contest/1399/problem/A">ссылке</a>.</p>
<h1 id="Анализ-условия"><a class="header" href="#Анализ-условия">Анализ условия</a></h1>
<p>Переформулируем условие :</p>
<blockquote>
<p>Дан массив. Вы несколько раз (возможно ноль) выбираете два разных индекса \( i \) и \( j\) таких, что \( |a_i - a_j| \le 1 \), и удаляете наименьший элемент из этих двух (если они равны то удаляете любой). Определите возможно ли получить массив, состоящий только из одного элемента. (<code>YES</code>/<code>NO</code>)</p>
</blockquote>
<h1 id="Алгоритм"><a class="header" href="#Алгоритм">Алгоритм</a></h1>
<ol>
<li>
<p>&quot;На какую тему задача?&quot;. Данная задача взята не из конкретной лабы, но вчитаемся чуть внимательнее в условие. 
Учитывая, что мы удаляем из двух выбранных элементов минимальный, то логичным будет утверждение о том, что если ответ <code>YES</code>, то наш оставшийся элемент - максимальный.
Так мы пришли к тому, что задача, вероятнее всего, будет связана с сортировкой.</p>
</li>
<li>
<p>Время определить, как именно нам поможет сортировка, и какой алгоритм мы должны выстроить вокруг неё. Для этого достаточно рассмотреть последнее удаление — мы выбрали \(x\) и \(y\), где \(y \le x\). Следовательно максимальный элемент массива \(a\) невозможно удалить, а так-же \(y=x\) или \(y=x-1\). Из всего вышеперечисленного можно сделать вывод, что при оптимальном процессе удаления, числа, которые удаляются, не уменьшаются. Значит решение заключается в том, чтобы отсортировать массив и сравнить на разность соседние элементы.</p>
</li>
<li>
<p>Реализуем поэтапно наше решение, в ходе чего будем анализировать каждый шаг и возможность его оптимизации.</p>
</li>
<li>
<p>Протестируем наше решение готовыми тестами из условия, а также напишем несколько своих тестов, задумавшись о ситуациях, где входные данные могут иметь нерядовой случай, который мы могли не учесть, и который сломает наше решение.</p>
</li>
</ol>
<p>Пункт (4) остаётся на размышление читателям.</p>
<p>Решение формально выглядит так :</p>
<ol>
<li>считать массив</li>
<li>отсортировать его</li>
<li>сравнить соседние элементы. И если где-то разница элементов больше единицы, то ответ <code>NO</code>, иначе <code>YES</code>.</li>
</ol>
<p>Введите код из листинга ниже в файл <code>main.cpp</code>.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int a[50];

void solve() {
    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    sort(a, a + n);
    for (int i = 0; i + 1 &lt; n; i++) {
        if (a[i + 1] - a[i] &gt; 1) {
            cout &lt;&lt; &quot;NO\n&quot;;
            return ;
        }
    }
    cout &lt;&lt; &quot;YES\n&quot;;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--) {
        solve();
    }
    return 0;
}
</code></pre>
<p>Этот код содержит много информации, поэтому рассмотрим его построчно. </p>
<p>Для ввода данных и последующей печати ответов нам необходимо подключить библиотеку <code>iostream</code>. Для этого напишем <code>#include &lt;iostream&gt;</code>, а <code>using namespace std;</code> помогает использовать пространство имён. (не берите в голову)</p>
<p>Функция <code>main</code> запускается каждый раз при запуске программы. Ещё <code>main</code> называют точкой входа в программу. Функция ничего не принимает, поэтому мы написали <code>()</code>. Тело любой функции заключается в <code>{}</code>. Перед <code>main</code> написано <code>int</code> — тип результата функции, возвращаем мы 0 (<code>return 0</code>). Именно <code>0</code>, так-как это код возврата программы и чтобы не получить <code>RE</code> он должен быть <code>0</code>.</p>
<p>Как видно <code>solve</code> тоже функция, но тип перед ней <code>void</code> — пустой тип, поэтому мы и делаем <code>return ;</code>.</p>
<h1 id="Типы-данных"><a class="header" href="#Типы-данных">Типы данных</a></h1>
<p>В <code>c++</code>, как и во всех языках программирования много типов данных. <code>int/float/string</code> и тп.</p>
<p>В задаче нам нужны типы для длины массива и количество тестов <code>t</code>. Для таких переменных подходят числа, а их тип <code>int</code>, от слова <code>Integer</code>.</p>
<p>Массив чисел создаётся в формате <code>тип НазваниеПеременной[КоличествоЭлементов]</code></p>
<h1 id="Ввод-и-вывод-данных"><a class="header" href="#Ввод-и-вывод-данных">Ввод и вывод данных</a></h1>
<p>Данные можно вводить и выводить различными способами, но самое простое это использовать стандартные потоки.</p>
<p>Так как ввод посимвольная операция, то <code>cin &gt;&gt; t;</code> попробует считывать символы до пробела, и запишет число в <code>t</code>, так как переменная <code>t</code> типа <code>int</code>. (<code>&gt;&gt;</code> оператор, который лишь <code>перегружен</code> для ввода из потока)</p>
<p>Например, <code>cout &lt;&lt; &quot;YES\n&quot;;</code> — выведет три символа <code>Y</code> <code>E</code> <code>S</code>, а затем выведет <code>\n</code> — символ новой строки. </p>
<h1 id="Сортировка-и-циклы"><a class="header" href="#Сортировка-и-циклы">Сортировка и циклы</a></h1>
<p>Сортировка это лишь стандартная функция. Для сортировки по не убыванию достаточно передать в качестве аргументов два указателя на память, на начало и конец. Если проще, то просто <code>a</code> и <code>a+n</code>.</p>
<p><code>for</code> и <code>while</code> — циклы.</p>
<h1 id="Последние-штрихи"><a class="header" href="#Последние-штрихи">Последние штрихи</a></h1>
<p>Я написал отдельную функцию <code>solve</code> и запустил её <code>t</code> раз (только красиво). </p>
<p>Условие в цикле для сравнения соседних элементов я написал <code>i + 1 &lt; n</code>, чтобы не было <code>RE</code>, при чтение ненужной памяти. Собственно если разница больше единицы, то я моментально прекращаю работу функции используя <code>return ;</code>.</p>
<p>Следовательно если ответ на задачу должен быть <code>YES</code>, то после выполнения цикла выведется корректный ответ.</p>
<p>Очень многое опущено — поэтому углубитесь в язык программирования <code>c++</code> и задавайте вопросы)))</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Основы-c"><a class="header" href="#Основы-c">Основы C++</a></h1>
<p>В этой главе рассматриваются понятия, встречающиеся практически во всех языках программирования, и то, как они работают в <code>c++</code>. Многие языки программирования имеют много общего в своей основе. Ни одна из концепций, представленных в этой главе, не является уникальной для <code>c++</code>, но мы обсудим их в контексте <code>c++</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Типы-данных-в-С"><a class="header" href="#Типы-данных-в-С">Типы данных в С++</a></h1>
<p>Поговорим об основах - типах данных в языке С++.
Самые популярные типы данных по группам:</p>
<ul>
<li>числовые</li>
<li>логические</li>
<li>символьные</li>
<li>пользовательские</li>
</ul>
<p>Теперь давайте поподробнее разберем каждую из групп.</p>
<h1 id="Числовые-типы-данных"><a class="header" href="#Числовые-типы-данных">Числовые типы данных</a></h1>
<p>Рассмотрим самые популярные числовые типы:</p>
<ul>
<li><code>int</code> - хранит целые числа, весит 4 байта, вмещает числа в диапазоне от -2 147 483 648 до 2 147 483 647</li>
<li><code>long long</code> - хранит целые числа, весит 8 байт, вмещает числа в диапазоне от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807</li>
<li><code>float</code> - хранит вещественные числа одинарной точности с плавающей точкой в диапазоне +/- 3.4E-38 до 3.4E+38. В памяти занимает 4 байта</li>
<li><code>double</code> - хранит вещественные числа двойной точности с плавающей точкой в диапазоне +/- 1.7E-308 до 1.7E+308. В памяти занимает 8 байт </li>
<li><code>unsigned int</code> - хранит целое положительное число, весит 4 байта, вмещает числа в диапазоне от 0 до 4 294 967 295</li>
<li><code>unsigned long long</code> - хранит целое положительное число, весит 8 байт, вмещает числа в диапазоне от 0 до 18 446 744 073 709 551 615</li>
</ul>
<h1 id="Логический-тип-данных"><a class="header" href="#Логический-тип-данных">Логический тип данных</a></h1>
<p>Логический тип <code>bool</code> может хранить одно из двух значений: true (истинно, верно) и false (неверно, ложно). </p>
<blockquote>
<p>При выводе значения типа <code>bool</code> преобразуются в 1 (если true) и 0 (если false). Значение по умолчанию для переменных этого типа - false. Как правило, данный тип применяется преимущество в условных выражениях.</p>
</blockquote>
<h1 id="Символьный-тип-данных"><a class="header" href="#Символьный-тип-данных">Символьный тип данных</a></h1>
<p><code>char</code> - символьный тип данных в C++. Весит 1 байт и имеет диапазон от 0 до 225 (или от -128 до 127 signed) и обозначает номер отображаемого символа в таблице ASCII. Модифицируется с помощью signed/unsigned. </p>
<h1 id="Пользовательские-типы-данных"><a class="header" href="#Пользовательские-типы-данных">Пользовательские типы данных</a></h1>
<p>Иногда нам может не хватить функционала встроенных типов данных. Например, мы хотели бы создать некого студента и хранить его имя, группу и средний балл по алгоритмам. Это можно было бы реализовать, создавая для каждого студента 3 отдельные переменные и хранить у себя в голове, какая переменная к какому относится. Очевидно, что это максимально неудобно, и тут нам и придут на помощь пользовательские типы данных.</p>
<blockquote>
<p>С помощью структур и некоторых других пользовательских типов мы можем объединять различные данные, которые хотим связать вместе.</p>
</blockquote>
<p>Мы знаем, что хотим для каждого студента хранить одни и те же параметры. Мы создадим структуру студента и в поля структуры запишем нужные параметры, а дальше просто будем создавать экземпляры студентов, которые будут иметь одинаковые параметры, которые еще и будут привязаны к каждому из студентов.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
struct student
{
    int age;
    std::string name;//имя храним в строке, строки разберем немного позже
    int average_points;
};
 
int main()
{
    person first_student;
    first_student.name = &quot;Tom&quot;;
    first_student.age = 34;
    first_student.average_points = 25;
    std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; first_student.name &lt;&lt; &quot;\tAge: &quot; &lt;&lt; first_student.age &lt;&lt; &quot;Average pts: &quot; &lt;&lt; first.student &lt;&lt; std::endl;
}
</code></pre>
<p>Подробнее о структурах, классах и других пользовательских типах вы узнаете чуть позже, в отдельном разделе, посвященном этому!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ввод-и-вывод"><a class="header" href="#Ввод-и-вывод">Ввод и вывод</a></h1>
<p>Существует много способов для ввода и вывода данных. На наш взгляд, самым удобным является ввод и вывод через стандартные потоки <code>cin</code> на ввод и <code>cout</code> на вывод.</p>
<p>Более подробная информация находится на cppreference (<a href="https://en.cppreference.com/w/cpp/io/cin">cin</a>, <a href="https://en.cppreference.com/w/cpp/io/cout">cout</a>).</p>
<p>Буква <code>c</code> в названии означает &quot;символ&quot;, <code>cin</code> — ввод символов, <code>cout</code> — вывод символов.</p>
<p>Первым делом стоит подключить библиотеку <code>iostream</code>, которая содержит реализацию этих потоков, и ещё прописать <code>using namespace std;</code>.</p>
<h1 id="Ввод"><a class="header" href="#Ввод">Ввод</a></h1>
<p>Для выполнения операций ввода переопределен оператор <code>&gt;&gt;</code>.</p>
<blockquote>
<p>При выполнение <code>cin &gt;&gt; x;</code> из входного потока читается последовательность символов до пробела, затем эта последовательность преобразуется к типу переменной <code>x</code>, и получаемое значение помещается в переменную <code>x</code>.</p>
</blockquote>
<p>Если <code>cin</code> не смог сконвертировать входные данные в ожидаемый формат, то он будет помечен как ошибка и программа может завершиться с ошибкой (RE).</p>
<p>Можно вводить сразу много переменных и сразу разных типов — <code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; c &gt;&gt; d;</code>.</p>
<h1 id="Считывание-строки-не-типа"><a class="header" href="#Считывание-строки-не-типа">Считывание строки (не типа)</a></h1>
<p>Для этого существует функция <code>getline</code> из той-же библиотеки.</p>
<p>Прочтите, например, <a href="https://en.cppreference.com/w/cpp/string/basic_string/getline">тут</a>.</p>
<h1 id="Вывод"><a class="header" href="#Вывод">Вывод</a></h1>
<p>Всё аналогично вводу, только перегружен оператор <code>&lt;&lt;</code>.</p>
<p>Команда <code>cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';</code> — выполнится только в том случае, если переменная <code>x</code> и <code>y</code> будут иметь реализацию для вывода (все базовые типы умеют это делать, но при выводе массив будет адрес (далее поймём почему)).</p>
<p><code>'\n'</code> — символ перевода каретки (переход на новую строки). <code>endl</code> (<code>std::endl</code>) — хуже. Он делает тоже самое, но дополнительно делает достаточно бесполезное действие с буфером. </p>
<h1 id="Ускорение-ввода"><a class="header" href="#Ускорение-ввода">Ускорение ввода</a></h1>
<p>Можно катастрофически ускорить чтение всего парами строками, размещённой в начале программы (в main сразу напишите): </p>
<pre><code class="language-cpp">ios::sync_with_stdio(false);
cin.tie(0); cout.tie(0);
</code></pre>
<p>Если интересно, то <a href="https://codeforces.com/blog/entry/90775">прочтите</a> почему это так.</p>
<p>Вообще можно построить свой буферный ввод и вывод, но таким не стоит заниматься.</p>
<p>Используйте <code>'\n'</code> вместо <code>std::endl</code>.</p>
<p>Хорошенько потренируйтесь, попробуйте вводить и выводить разные типы. Когда поймёте, что поняли эту тему, можете смело приступать к следующему уроку.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ветвление"><a class="header" href="#Ветвление">Ветвление</a></h1>
<p>Встречаются ситуации, когда программе нужно выбрать, какую операцию ей выполнить, в зависимости от определенного условия.</p>
<p>К примеру, мы вводим с клавиатуры целое число. Если это число больше десяти, то программа должна выполнить одно действие, иначе — другое. Реализуем этот алгоритм на C++ с помощью конструкции ветвления.</p>
<p>Пример конструкции ветвления:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    double num;

    cout &lt;&lt; &quot;Введите произвольное число: &quot;;
    cin &gt;&gt; num;

    if (num &lt; 10) { // Если введенное число меньше 10.
        cout &lt;&lt; &quot;Это число меньше 10.&quot; &lt;&lt; endl;
    } else { // иначе
        cout &lt;&lt; &quot;Это число больше либо равно 10.&quot; &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
<p>Если вы запустите эту программу, то при вводе числа, меньшего десяти, будет выводиться соответствующее сообщение.</p>
<p>Если введенное число окажется большим, либо равным десяти — отобразится другое сообщение.</p>
<blockquote>
<p>Оператор if:
Оператор if служит для того, чтобы выполнить какую-либо операцию в том случае, когда условие является верным. Условная конструкция в С++ всегда записывается в круглых скобках после оператора if.</p>
</blockquote>
<p>Внутри фигурных скобок указывается тело условия. Если условие выполнится, то начнется выполнение всех команд, которые находятся между фигурными скобками.</p>
<p>Пример конструкции ветвления:</p>
<pre><code class="language-cpp">if (num &lt; 10) {  // Если введенное число меньше 10.
    cout &lt;&lt; &quot;Это число меньше 10.&quot; &lt;&lt; endl;
} else {  // иначе
    cout &lt;&lt; &quot;Это число больше либо равно 10.&quot; &lt;&lt; endl;
}
</code></pre>
<p>Здесь говорится: «Если переменная num меньше 10 — вывести соответствующее сообщение. Иначе, вывести другое сообщение».</p>
<p>Усовершенствуем программу так, чтобы она выводила сообщение, о том, что переменная num равна десяти:</p>
<pre><code class="language-cpp">if (num &lt; 10) {  // Если введенное число меньше 10.
    cout &lt;&lt; &quot;Это число меньше 10.&quot; &lt;&lt; endl;
} else if (num == 10) {
    cout &lt;&lt; &quot;Это число равно 10.&quot; &lt;&lt; endl;
} else {  // иначе
    cout &lt;&lt; &quot;Это число больше 10.&quot; &lt;&lt; endl;
}
</code></pre>
<p>Здесь мы проверяем три условия:
Первое — когда введенное число меньше 10-ти,
Второе — когда число равно 10-ти,
И третье — когда число больше десяти,
Заметьте, что во втором условии, при проверке равенства, мы используем оператор равенства &quot;==&quot;, а не оператор присваивания, потому что мы не изменяем значение переменной при проверке, а сравниваем ее текущее значение с числом 10.Если поставить оператор присваивания в условии, то при проверке условия, значение переменной изменится, после чего это условие выполнится.</p>
<blockquote>
<p>Оператор else используется только в связке с оператором if и каждому if может соответствовать только один else. Инструкции, находящиеся внутри блока else, будут выполнены только в случае, если не выполнен if, к которому привязан блок else. В противном случае условия в блоке else будут проигнорированы. </p>
</blockquote>
<p>Оператор else if означает, что если не будут выполнены условия в предыдущем блоке if, то программа проверит условия в текущем и выполнит инструкции, при верности условий.
Если после оператора if, else или их связки else if должна выполняться только одна команда, то фигурные скобки можно не ставить. Предыдущую программу можно записать следующим образом:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    double num;

    cout &lt;&lt; &quot;Введите произвольное число: &quot;;
    cin &gt;&gt; num;

    if (num &lt; 10) // Если введенное число меньше 10.
        cout &lt;&lt; &quot;Это число меньше 10.&quot; &lt;&lt; endl;
    else if (num == 10)
        cout &lt;&lt; &quot;Это число равно 10.&quot; &lt;&lt; endl;
    else  // иначе
        cout &lt;&lt; &quot;Это число больше 10.&quot; &lt;&lt; endl;

    return 0;
}
</code></pre>
<p>Такой метод записи выглядит более компактно. Если при выполнении условия нам требуется выполнить более одной команды, то фигурные скобки необходимы. Например:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    double num;
    int k;

    cout &lt;&lt; &quot;Введите произвольное число: &quot;;
    cin &gt;&gt; num;

    if (num &lt; 10) {  // Если введенное число меньше 10.
        cout &lt;&lt; &quot;Это число меньше 10.&quot; &lt;&lt; endl;
        k = 1;
    } else if (num == 10) {
        cout &lt;&lt; &quot;Это число равно 10.&quot; &lt;&lt; endl;
        k = 2;
    } else {  // иначе
        cout &lt;&lt; &quot;Это число больше 10.&quot; &lt;&lt; endl;
        k = 3;
    }

    cout &lt;&lt; &quot;k = &quot; &lt;&lt; k &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>Данная программа проверяет значение переменной num. Если она меньше 10, то присваивает переменной k значение единицы. Если переменная num равна десяти, то присваивает переменной k значение двойки. В противном случае — значение тройки. После выполнения ветвления, значение переменной k выводится на экран.</p>
<p>Хорошенько потренируйтесь, попробуйте придумать свой пример с ветвлением. Когда поймете, что поняли эту тему, можете смело приступать к следующему уроку.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Циклы"><a class="header" href="#Циклы">Циклы</a></h1>
<p>Часто бывает полезно выполнить блок кода более одного раза. Например, ввести массив.</p>
<p>Для этого в <code>c++</code> предусмотрено несколько циклов, которые будут выполнять код внутри тела цикла до конца, а затем сразу же возвращаться в начало. Чтобы поэкспериментировать с циклами.</p>
<p>В <code>c++</code> есть три вида циклов: <code>for</code>, <code>while</code> и <code>do</code>. Попробуем использовать каждый из них.</p>
<h1 id="Цикл-while"><a class="header" href="#Цикл-while">Цикл <code>while</code></a></h1>
<p>Синтаксис <code>while ( condition ) { loop-body }</code></p>
<p>Ключевое слово <code>while</code> указывает на то, что пока условие истинно, цикл выполняется. Когда условие перестаёт быть истинным, программа вызывает <code>break</code>, останавливая цикл. Другое название цикла <code>while</code> — <code>цикл с условием</code></p>
<p>Далее мы рассмотрим <code>break</code> подробнее, но в данном случае но завершает выполнение цикла.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int t = 5;
    while (t != 0) {
        cout &lt;&lt; t &lt;&lt; endl;
        t--;
    }
    cout &lt;&lt; t;
}
</code></pre>
<p>Если запустить код вы получите :</p>
<pre><code class="language-bash">5
4
3
2
1
0
</code></pre>
<p>Цикл <code>while</code> повторился <code>4</code> раза. Сначала <code>t=5</code>, потом <code>t=4</code>, затем <code>t=3</code>, <code>t=2</code>, <code>t=1</code>. В случае <code>t=1</code> мы выведем <code>1</code>, а затем уменьшим <code>t</code> на один, итерация цикла закончится. В следующую итерацию, когда <code>while</code> решит проверить условие <code>t != 0</code>, получится <code>false</code>, а следовательно цикл закончится. После окончания цикла дальнейший код будет выполняться — <code>cout &lt;&lt; t;</code>.</p>
<h1 id="Цикл-for"><a class="header" href="#Цикл-for">Цикл <code>for</code></a></h1>
<p>Синтаксис  <code>for (init-statement; condition; iteration-expression) { loop-body }</code></p>
<p>Выполняется <code>init-statement</code> всего один раз, затем выполняется тело цикла, если <code>condition</code> имеет положительный результат (<code>true</code>). После одной итерации выполняется <code>iteration-expression</code> и по дальше выполняется следующая итерация.</p>
<p>Давайте напишем программу, которая выведет все чётные числа, которые находятся между <code>a</code> и <code>b</code>, которые вводятся.</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int a, b;
    cin &gt;&gt; a &gt;&gt; b;
    for (int x = a; x &lt;= b; x++) {
        if (x % 2 == 0) {
            cout &lt;&lt; x &lt;&lt; endl;
        }
    }
}
</code></pre>
<p>При вводе <code>6 9</code> программа выведет :</p>
<pre><code class="language-bash">6 
8
</code></pre>
<h1 id="Операторы-break-и-continue"><a class="header" href="#Операторы-break-и-continue">Операторы break и continue</a></h1>
<p>Иногда при использовании циклов появляется необходимость прервать цикл или пропустить одну итерацию. Для этого в C++ существуют операторы перехода break и continue, рассмотрим каждый из них поподробнее.</p>
<blockquote>
<p>Оператор <code>break</code> позволяется завершить цикл, это происходит сразу после выполнения инструкции. Давайте разберем простой пример использования оператора <code>break</code></p>
</blockquote>
<p>Допустим, что мы хотим посчитать сумму чисел от 1 до N включительно, но если сумма будет переваливать значение границы, которое ввел пользователь, то мы должны вывести максимальное значение суммы, не превышающее границу, и количество чисел, которые мы сложили в ходе решения.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
  
int main() {
    int n;
    std::cin &gt;&gt; n; //максимальное число которое можно будет прибавить к сумме
    
    int result = 0;//итоговая сумма
    
    int bound;//граница за которую нельзя перевалить
    std::cin &gt;&gt; bound;
    
    int els_in_sum = 0;//сколько элементов учвствует в сумме
    
    for(int i = 1; i &lt; n + 1; i++) { //цикл от 1 до N включительно
      
        if(result + i &gt; bound) {
            break;//если текущая сумма + i переваливает за границу, то выходим из цикла
        }
        els_in_sum += 1;//иначе увеличиваем количество элементов в сумме на 1
        result += i ;//и сумму на 1
    }
    std::cout &lt;&lt; result &lt;&lt; &quot; &quot; &lt;&lt; els_in_sum;//выводим сумму и количество элементов в ней
}
</code></pre>
<p>Заметьте, что мы можем не пользоваться оператором <code>else</code> в данном случае, т.к цикл попросту завершится при выполнении условия в <code>if</code>. Формально увеличение суммы происходит только когда верхнее условие не соблюдается, но это можно не писать из-за оператора <code>break</code>, который остановит цикл, как только условие выполнится.</p>
<blockquote>
<p>Оператор <code>continue</code> позволяет пропустить текущую итерацию в цикле, пропуская все инструкции, написанные ниже него, для текущей итерации</p>
</blockquote>
<p>Рассмотрим простейший пример. Посчитаем сумму нечетных чисел от 1 до N;</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int N;
    std::cin &gt;&gt; N;//считали с консоли N 

    int sum = 0;//создали сумму со стартовым значением 0

    for(int i = 0; i &lt; N + 1; ++i) { //цикл по всем числа в диапазоне
        if (N % 2 == 0) {
            continue;//если число делится на 2 без остатка, то есть является четным, 
            //пропустить все инструкции и перейти к следующей итерации
        }
        sum += i;//прибавляем к текущей сумме число i 
    }

    std::cout &lt;&lt; sum;//вывели ответ
}
</code></pre>
<p>Так как инструкция суммирования идет после оператора <code>continue</code>, то для четных чисел она будет попросту пропущена, как и все инструкции, которые могли бы быть написаны после <code>continue</code>. Для нечетных чисел итерация пропускаться не будет, и они будут добавлены в сумму.</p>
<h1 id="Цикл-do"><a class="header" href="#Цикл-do">Цикл <code>do</code></a></h1>
<p>Синтаксис <code>do { loop-body } while (condition);</code></p>
<p>Выполняет оператор многократно, пока значение выражения не станет ложным. Проверка происходит после каждой итерации, а в <code>while</code> до. </p>
<p>Рассмотрим пример :</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main() {
    int t = 5;
    do {
        cout &lt;&lt; t &lt;&lt; endl;
        t--;
    } while (t != 0 &amp;&amp; t != 5);
    cout &lt;&lt; t;
}
</code></pre>
<p>Если запустить код вы получите :</p>
<pre><code class="language-bash">5
4
3
2
1
0
</code></pre>
<p>Как видно часть условия <code>t != 5</code> не была нарушено, так как первый раз проверка производилась с <code>t=4</code>.</p>
<blockquote>
<p><code>do</code> удобен лишь для <a href="./how-to-testing.html">стрес-тестов</a>. С <code>do</code> надо использовать <a href="https://en.cppreference.com/w/cpp/algorithm/next_permutation">next_permutation</a> для перебора всех перестановок.</p>
</blockquote>
<p>Хорошенько потренируйтесь, попробуйте придумать свой пример с циклами. Когда поймёте, что поняли эту тему, можете смело приступать к следующему уроку.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Массивы"><a class="header" href="#Массивы">Массивы</a></h1>
<h1 id="Что-это-такое-и-зачем-они-нужны"><a class="header" href="#Что-это-такое-и-зачем-они-нужны">Что это такое и зачем они нужны</a></h1>
<p>Массивы — это способ хранения списка элементов. Чтобы, например, создать список имён учебной группы мы могли бы создать 25 переменных и каждой отдельно присвоить значения, но это долго и неудобно. Тут на помощь нам и придут массивы.</p>
<blockquote>
<p>Массив в C/C++ или любом другом языке программирования-это набор элементов одинакового типа, хранящихся в смежных ячейках памяти, где доступ к элементам может быть произвольным, используя индексы массива. Напомним, что индексация в массивах в C++ начинается с 0.</p>
</blockquote>
<h1 id="Виды-массивов"><a class="header" href="#Виды-массивов">Виды массивов</a></h1>
<p>В данной главе мы изучим различные типы массивов, а также рассмотрим понятие <a href="./VLA.html">VLA</a> и наиболее удобную структуру данных для хранения элементов в языке C++ — <code>std::vector</code>..</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Статические-массивы"><a class="header" href="#Статические-массивы">Статические массивы</a></h1>
<p>Массивы бывают двух типов: <a href="./c-array.html">статические</a> и <a href="dynamic-array.html">динамические</a>. Давайте, рассмотрим статические.</p>
<h1 id="Особенности-статических-массивов"><a class="header" href="#Особенности-статических-массивов">Особенности статических массивов</a></h1>
<blockquote>
<p>Главная особенность статических массивов - неизменяемый размер. Размер статического массива должен быть известен до компиляции, то есть считать с консоли переменную N и после создать массив размером N не получится, размер массива должен быть только константой, например, числом 2352. </p>
</blockquote>
<p>Давайте рассмотрим объявление и инициализацию массива:</p>
<pre><code class="language-cpp">int my_second_array[5] = {1,2,3,4,5};
int my_first_array[25];
my_first_array[0] = 1;
my_first_array[1] = 2;
my_first_array[2] = 3;
</code></pre>
<p>В первой строке мы создали массив размером 5 и сразу задали значения всем пяти его ячейкам.
Далее мы объявили массив целочисленного типа данных int с именем my_first_array и вместимостью 25, а после инициализировали его первые три ячейки значениями 1, 2 и 3, соответственно.</p>
<h1 id="Итерация-по-элементам-массива"><a class="header" href="#Итерация-по-элементам-массива">Итерация по элементам массива</a></h1>
<p>Доступ к элементам массива происходит по следующей форме: имя_Массива[индекс_нужного, элемента]
В примере выше по такой формуле мы задали значения элементам массива my_first_array.</p>
<pre><code class="language-cpp">my_first_array[0] = 1; //имя массива - my_first_array, индекс нужного элемента - 0
my_first_array[1] = 2; //имя массива - my_first_array, индекс нужного элемента - 1
my_first_array[2] = 3; //имя массива - my_first_array, индекс нужного элемента - 2
</code></pre>
<p>Теперь самое время задаться вопросом, &quot;А что делать, если у меня массив из 25 элементов, и я хочу каждый элемент сделать больше на 2, чем предыдущий. Мне что, 25 раз считать самому/самой и 25 раз писать процедуру присваивание?!&quot;. 
К счастью, нет. Тут нам на помощь приходят циклы, в частности цикл for(). </p>
<p>Давайте воспользуемся циклом for(), чтобы считать N элементов в наш массив, а после вывести их на консоль.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int N = 256; 
    int my_array[N]; //создали массив целочисленного типа размера N. Строкой выше мы присвоили N значение константы 256, так что можем себе позволить использовать переменную как параметр размера. Размер массива будет, соответственно, 256

    for (int i = 0; i &lt; N; i++) { //переменная i будет увеличиваться каждую итерацию и принимать значения в диапазоне от 0 до N-1 включительно, то есть мы сможем обратить к первым N элементам.
        std::cin &gt;&gt; my_array[i]; //считываем данные с консоли и присываиваем их элементу массива с номером i
    }
    
    for (int i = 0; i &lt; N; i++) {
        std::cout &lt;&lt; my_array[i] &lt;&lt; &quot; &quot;; //поочередно выводим все элементы
    }
}
</code></pre>
<p>В комментариях в коде построчно объяснена логика программы. Теперь давайте попробуем справиться с проблемой, о которой мы переживали чуть выше. Как сделать элементы массива такими, чтобы предыдущий был меньше текущего на 2</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int N = 256; 
    int my_array[N]; //создали массив
    my_array[0] = 1; // приравняли к единице первый элемент массива

    for (int i = 1; i &lt; N; i++) { 
        my_array[i] = my_array[i - 1] + 2;
    }
    
    for (int i = 0; i &lt; N; i++){
        std::cout &lt;&lt; my_array[i] &lt;&lt; &quot; &quot;; //поочередно выводим все элементы
    }
}
</code></pre>
<p>Давайте внимательно посмотрим на наш код. Мы приравняли первый элемент массива к единице, чтобы нам было, к чему прибавлять двойку. Далее мы проходимся циклам по всем элементам массива с индексами от 1 до N-1 включительно.</p>
<p>Почему с единицы, наверное, хотите спросить вы. Мы ответим, потому что: 
а)элемент с нулевым индексом мы уже приравняли к единице и больше не будем менять его значение
б) my_array[i] = my_array[i-1] + 2; Здесь мы обращаемся к элементу my_array[i-1], чтобы узнать значение предыдущего элемента перед текущим с индексом i. Если бы мы начали цикл не с 1, а с 0, то программа бы обратилась к элементу my_array[0-1], то есть к элементу с индексом -1, что является ошибкой.</p>
<blockquote>
<p>Всегда помните о том, что вы не должны выходить за границы массива.</p>
</blockquote>
<h1 id="Указатель"><a class="header" href="#Указатель">Указатель</a></h1>
<p>Переменная статического массива на самом деле это указатель на первый элемент массива.</p>
<p>Следствия :</p>
<ol>
<li>
<p>Массивы нельзя присваивать. Так как просто указатель присвоить непонятно, что
делать с &quot;потерявшейся памятью&quot;. Ещё есть вариант когда можно перекопировать все переменные, но это работает за <code>O(n)</code>, решили такое не делать, хотя в векторе такое есть. Это пришло из <code>C</code> исторически.</p>
</li>
<li>
<p><code>sizeof(a)</code> гораздо больше чем `sizeof(pointer)``</p>
</li>
<li>
<p>Если вы сравните два массива с помощью <code>==</code>, он сравнит адреса массивов, поэтому он даст результат <code>true</code> только в том случае, если вы сравните массив с самим собой (или с указателем на элемент того же типа). В большинстве контекстов имена массивов превращаются в указатель на первый элемент массива. Вот почему многие новички думают, что массивы и указатели — это одно и то же. На самом деле это не так. Они разных типов.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Динамические-массивы"><a class="header" href="#Динамические-массивы">Динамические массивы</a></h1>
<p>Массивы бывают двух типов: <a href="./c-array.html">статические</a> и <a href="dynamic-array.html">динамические</a>. Давайте, рассмотрим динамические.</p>
<blockquote>
<p>Главная особенность динамических массивов - изменяемый размер. Размер динамического массива может быть любим неотрицательным числом. </p>
</blockquote>
<p>Например, вам надо создать массив на <code>n</code> элементов (<code>n</code> вы ввели).</p>
<p>Для этого можно воспользоваться <code>new[]</code>.</p>
<pre><code class="language-cpp">int* foo = new int[10];
</code></pre>
<blockquote>
<p><code>new T</code> возвращает указатель на начало переменной памяти типа <code>T *</code>. </p>
</blockquote>
<p>Далее, мы используем массив так-же как и статический массив, но после работы нам стоит очистить выделенную <code>new</code> память, чтобы не получать <code>ML</code>.</p>
<blockquote>
<p>Чтобы очистить массив после использования надо выполнить <code>delete []foo</code>.</p>
</blockquote>
<p>После прочтения главы, рекомендую прочитать про <a href="./memory.html">устройство памяти</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vla"><a class="header" href="#vla">VLA</a></h1>
<blockquote>
<p>Скажу сразу, очень многие даже не знают о таком термине.</p>
</blockquote>
<p>VLA - это попытка упросить жизнь программисту, что бы он мог создавать массивы &quot;интуитивным способом&quot; (я специально взял в кавычки).
Поддерживается не всеми компиляторами. </p>
<p>Когда мы пишем <code>int a[x];</code> некоторые компиляторы могут это компилировать, даже если <code>x</code> только что введённая переменная. Создание происходит НЕ В КУЧЕ а на СТЕКЕ с использованием обычного <code>alloca</code> как создание обычного массива через указатели и <code>new</code>. Работает примерно также, но прячет все детали за &quot;магией&quot;компилятора. (грубо говоря на стеке рядом хранит данные что он создал VLA на определённое количество элементов)</p>
<blockquote>
<p>При наличии <code>std::vector</code> смысла в <code>VLA</code> для С++ нет никакого. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stdvector"><a class="header" href="#stdvector">std::vector</a></h1>
<p>Динамический массив настоящего альфы)))</p>
<p>Синтаксис <code>vector&lt;T&gt; variable(n);</code>. Стоит подключить библиотеку <code>&lt;vector&gt;</code>.</p>
<p>Под <code>капотом</code> находится <code>буфер</code>, который является динамическим массивом. 
Это позволяет быстро выполнять операции, которые изменяют размер вектора, так как <code>буфер</code> может быть зарезервирован на большее количество элементов, чем фактически требуется. Размер буфера имеет размер меньшей степени двойки. Например, если делать <code>n</code> <code>push_back</code> произойдёт <code>log n</code> реалокаций памяти.</p>
<blockquote>
<p>Используйте и не думайте.</p>
</blockquote>
<p>Есть удобные <a href="https://en.cppreference.com/w/cpp/container/vector">методы</a>: </p>
<p><code>push_back</code> — добавляет элемент в конец. Амортизировано за <code>o(1)</code>.</p>
<p><code>pop_back</code> — удаляет элемент в конец. Амортизировано за <code>o(1)</code>.</p>
<p><code>insert</code> — вставляет элемент в произвольное место. За <code>O(n)</code>.</p>
<p><code>erase</code> — удаляет произвольный элемент. За <code>O(n)</code>.</p>
<p><code>begin, end</code> — указатели на начало и конец. Например, нужно для сортировки <code>sort(a.begin(), a.end());</code></p>
<p>Пример решения задачи из блока <a href="./examples.html">&quot;начало работы&quot;</a> :</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

void solve() {
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }
    sort(a.begin(), a.end());
    for (int i = 0; i + 1 &lt; n; i++) {
        if (a[i + 1] - a[i] &gt; 1) {
            cout &lt;&lt; &quot;NO\n&quot;;
            return ;
        }
    }
    cout &lt;&lt; &quot;YES\n&quot;;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--) {
        solve();
    }
    return 0;
}
</code></pre>
<h1 id="vector-vs-динамический-массив"><a class="header" href="#vector-vs-динамический-массив">vector vs динамический массив</a></h1>
<p>Используйте <code>vector</code>, потому-что : </p>
<ol>
<li>не стоит задумывать о освобождение памяти</li>
<li>работает сравнение и копирование (так как переменная не указатель)</li>
<li>удобен во всех случаях, когда массив надо быстро изменить</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Что-выбрать"><a class="header" href="#Что-выбрать">Что выбрать?</a></h1>
<p>В данном случае, при решении задачи из блока <a href="./examples.html">&quot;начало работы&quot;</a>, я выбрал использование статического массива int a[50], так как максимальный размер был ограничен по условию. Однако, возможны и другие варианты, такие как динамические массивы, <code>VLA</code> или <code>std::vector</code>.</p>
<p>Моя рекомендация - использовать либо статические массивы, либо <code>std::vector</code>. По скорости статический массив немного быстрее, так как это менее абстрактная структура данных, чем <code>std::vector</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Функции-в-С"><a class="header" href="#Функции-в-С">Функции в С++</a></h1>
<h1 id="Что-зачем-и-почему"><a class="header" href="#Что-зачем-и-почему">Что, зачем и почему</a></h1>
<blockquote>
<p>Функция — часть кода, доступная из разных частей программы и содержащая некоторые инструкции, выполняемые только в случае вызова этой функции.</p>
</blockquote>
<p>Зачем нам вообще нужна функции? Функции помогают избежать многократного написания одного и того же кода. Для простоты понимания давайте рассмотрим простейшую программу:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int max(int x, int y) { //объявили функцию max типа int которая принимает два параметра типа int
    if (x &gt; y)
        return x; //возвращает значение x если выполняется условие x &gt; y
    else
        return y; //возвращает значение y если не выполнился if выше
}

int main() {
    int a = 10, b = 20;

    int m = max(a, b); //вызвали функцию и сохранили в переменную

    cout &lt;&lt; &quot;m is &quot; &lt;&lt; m; //вывели результат функции
    return 0;
}
</code></pre>
<p>Разберем эту программу по частям. Сперва мы создаем функцию типа int, принимающую параметры x и y, оба имеющие тип данных int. Как вы уже заметили, функция имеет тип данных int, что означает, что после выполнения каких-либо условий, она обязана вернуть целое число. </p>
<blockquote>
<p>Если в функции сработает инструкция return, то функция прекратит свою работу. Она отправит возвращаемое значение в main или любую другую часть кода, откуда была вызвана и завершит работу. Важно помнить, что переменные, созданные в функции, перестают существовать вместе с функцией!</p>
</blockquote>
<p>Теперь поговорим о параметрах х и у. Так как объявление функции max находится вне основной функции main, то функция max не имеет доступа к переменным, созданных в main. Тогда как функция max узнает, с какими параметрами ей работать? Для этого при вызове функции int m = max(a, b); в скобках мы указываем два параметра, которые мы хотим отправить в функцию. Заметим, что т.к. тип функции max - int, то результат функции - целое число, и мы можем сохранить результат работы нашей функции в целочисленную переменную, в данном случае - в переменную m. </p>
<h1 id="Типы-функций"><a class="header" href="#Типы-функций">Типы функций</a></h1>
<blockquote>
<p>Функции в C++ можно разделить на две большие группы: </p>
</blockquote>
<ul>
<li>Функции, возвращающие что-либо. Могут иметь тип и возвращать int, float, struct и вообще любой тип данных</li>
<li>Функции, не возвращающие ничего. Всегда при объявлении имеют тип void. Могут принимать параметры и изменять их, но не возвращают значений, соответственно, результат работы функции нельзя сохранить в переменную</li>
</ul>
<h1 id="Подведем-итоги"><a class="header" href="#Подведем-итоги">Подведем итоги</a></h1>
<p>Как вы заметили, в примере выше с функцией максимума двух чисел, код в main выглядит очень опрятно и понятно. А теперь представьте, если бы нам нужно было сравнить не одну пару,а 10. Без функций мы бы написали 10 * 4 строк одних только сравнений, а что, если бы нужно было делать что-то, куда более объемное, нежели сравнение двух чисел? Используя функции, мы бы лишь тратили строку на вызов функции, и строку на вывод результата. Даже в примере с крохотной max мы бы написали в 2 раза меньше кода в main!</p>
<p>Итак, давайте составим краткий список особенностей и фактов о функциях</p>
<ul>
<li>Помогают избежать многократного написания одинакового кода</li>
<li>Помогают сделать код в main куда более чистым и читаемым</li>
<li>Могут принимать различные параметры и выполнять операции над ними</li>
<li>Могут возвращать значения, которые можно как либо обработать и использовать дальше</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Передача-параметров-в-функцию"><a class="header" href="#Передача-параметров-в-функцию">Передача параметров в функцию</a></h1>
<blockquote>
<p>В С++ в функцию можно передать параметры тремя способами: по значению, по ссылке и по указателю. Сейчас мы рассмотрим каждый из вариантов</p>
</blockquote>
<h1 id="Передача-по-значению"><a class="header" href="#Передача-по-значению">Передача по значению</a></h1>
<blockquote>
<p>Фактически, при передаче параметров по значению, мы создаем копии каждого из переданных параметров внутри функции</p>
</blockquote>
<pre><code class="language-cpp">#include &lt;iostream&gt; 

void repchar(char ch, int n){
    for(int j = 0; j &lt; n; j++){ 
        std::cout &lt;&lt; ch;
        std::cout &lt;&lt; &quot;\n&quot;;
    }
}

int main() {
    char chin; 
    int nin;

    std::cout &lt;&lt; &quot;Введите символ: &quot;; 
    std::сin &gt;&gt; chin;
    std::cout &lt;&lt; &quot;Введите число повторений символа: &quot;; 
    std::cin &gt;&gt; nin; 

    repchar(chin, nin); 
}
</code></pre>
<p>Как вы заметили, функция repchar имеет тип void, что указывает на то, что функция не возвращает никаких значений. В данном случае функция просто напечатает полученный символ n раз. Так как мы передаем параметры по значению <code>void repchar(char ch, int n){</code>, то внутри функции будут созданы копии введенных параметров - ch = chin и n = nin. Такой подход просто и понятен, но не очень рационален с точки зрения использования памяти.</p>
<p>На картинке ниже проиллюстрирована схема передачи параметров в функцию по значению
<img src="./images/value_to_func.png" alt="Передача по значению" /></p>
<h1 id="Передача-по-ссылке"><a class="header" href="#Передача-по-ссылке">Передача по ссылке</a></h1>
<p>Как мы видели, функция не имеет доступа к переменным-аргументам, а работает со сделанными ей копиями значений. Разумеется, такой механизм полезен в тех случаях, когда у функции нет необходимости изменять значения аргументов, и мы защищаем аргументы от несанкционированного доступа.</p>
<blockquote>
<p>Вместо того чтобы передавать функции значение переменной, ей передается ссылка на эту переменную (фактически в функцию передается адрес переменной-аргумента в памяти). Важной особенностью передачи аргументов по ссылке является то, что функция имеет прямой доступ к значениям аргументов. </p>
</blockquote>
<pre><code class="language-cpp"> #include &lt;iostream&gt;

void intfrac(float n, float&amp; intp, float&amp; fracp) {
    long temp = static_cast&lt;long&gt;(n); // преобразование к типу long,
    intp = static_cast&lt;float&gt;(temp); // и обратно во float
    fracp = n - intp; // вычитаем целую часть
}

int main() {
    float number, intpart, fracpart;
    do{
        std::cout &lt;&lt; &quot;\nВведите вещественное число&quot;;
        std::cin &gt;&gt; number;
        intfrac(number, intpart, fracpart);
        std::cout &lt;&lt; &quot;целая часть равна &quot; &lt;&lt; intpart &lt;&lt; &quot; и дробная часть равна &quot; &lt;&lt; fracpart &lt;&lt; &quot;\n&quot;;
    } while (number != 0.0);
} 
</code></pre>
<p>В данном примере мы передали в функцию intfrac ссылки на переменные intpart и fracpart, тем самым позволив функции изменять значения, находящиехся по их адресам, а не создавать копии. Именно это позволяет функции записать ответ в созданные в main пемеренные и не думать о том, как передать сразу два объекта с помощью return.</p>
<p>На картинке проиллюстрированы отношения переменных и функции
<img src="./images/link_to_func.png" alt="link to func" /></p>
<h1 id="Передача-переменных-по-указателю"><a class="header" href="#Передача-переменных-по-указателю">Передача переменных по указателю</a></h1>
<blockquote>
<p>Передача указателя в функцию в качестве аргумента в некоторых случаях похожа на передачу по ссылке. Они обе позволяют переменной вызывающей программы быть измененной в функции. Однако их механизмы различны. Ссылка — это псевдоним переменной, а указатель — это адрес переменной.</p>
</blockquote>
<p>Давайте рассмотрим пример передачи в функцию переменной по указателю</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void centimize ( double* ptrd ){
    *ptrd *= 2.54; // *ptrd — это то же самое, что и var
    //потому что при операции разыменовывания ptrd мы получим доступ к данным переменной var
}

int main (){
    double var = 10.0; // значение переменной var равно 10 (дюймов)
    std::cout &lt;&lt; &quot;var = &quot; &lt;&lt; var &lt;&lt; &quot;дюймов&quot; &lt;&lt; &quot;\n&quot;;
    centimize ( &amp;var ); // передаем в функцию адрес перменной var
    std::cout &lt;&lt; &quot;var= &quot; &lt;&lt; var &lt;&lt; &quot;сантиметров&quot; &lt;&lt; endl;
}
</code></pre>
<p>Так как мы передаем в функцию адрес переменной var, то функция cementize создает указатель ptrd на тип double и присваиевает ему переданный в функцию адрес переменной var. После чего мы разыменовываем указатель и, получив доступ к var, умножаем ее значение на 2.54</p>
<p><img src="./images/ptr_var_to_func.png" alt="var to func w pointer" /></p>
<h1 id="Передача-массивов-по-указателю"><a class="header" href="#Передача-массивов-по-указателю">Передача массивов по указателю</a></h1>
<pre><code class="language-cpp">#include &lt;iostream&gt;

const int MAX = 5; // количество элементов в массиве

void centimize (double* ptrd)//передаем указатель на массив
{
    for ( int j = 0; j &lt; MAX; j++ ){
        *ptrd++ *= 2.54;//двигаем указатель на единицу, после разыменовываем и умножаем данные на 2.54
    }
}

int main ( )
{
    double varray [MAX] = { 10.0, 43.1, 95.9, 58.7, 87.3 };
    
    centimize(varray); // вызываем функцию, передав адрес первого элемента массива
    
    for (int j = 0; j &lt; MAX; j++){
        std::cout &lt;&lt; &quot;varray [ &quot; &lt;&lt; j &lt;&lt; &quot; ] = &quot; &lt;&lt; varray [ j ] &lt;&lt; &quot; сантиметров&quot; &lt;&lt; endl; //выведем результат
    }
}
</code></pre>
<pre><code class="language-bash">varray [ 0 ] = 25.4 сантиметров
varray [ 1 ] = 109.474 сантиметров
varray [ 2 ] = 243.586 сантиметров
varray [ 3 ] = 149.098 сантиметров
varray [ 4 ] = 221.742 сантиметров
</code></pre>
<p><img src="./images/ptr_array_to_func.png" alt="ptr array to func" /></p>
<p>Теперь рассмотрим вопрос синтаксиса: как узнать, что в выражении *ptrd++ увеличивается указатель, а не его содержимое? Другими словами, как компилятор интерпретирует это выражение: как *(ptrd++), что нам и нужно, или как (*ptrd)++? Здесь * (при использовании в качестве операции разыменования) и ++ имеют одинаковый приоритет. Однако операции одинакового приоритета различаются еще и другим способом: ассоциативностью. </p>
<p>Ассоциативность определяет, как компилятор начнет выполнять операции, справа или слева. В группе операций, имеющих правую ассоциативность, компилятор выполняет сначала операцию, стоящую справа. Унарные операции * и ++ имеют правую ассоциативность, поэтому наше выражение интерпретируется как *(ptrd++) и увеличивает указатель, а не то, на что он указывает. Таким образом, сначала увеличивается указатель, а затем к результату применяется операция разыменования.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Указатели"><a class="header" href="#Указатели">Указатели</a></h1>
<h1 id="Адреса-переменных-в-c"><a class="header" href="#Адреса-переменных-в-c">Адреса переменных в C++</a></h1>
<p>Сначала давайте разберемся с тем, зачем нам вообще гипотетически могут пригодиться указатели. </p>
<p>Самые частые примеры использования указателей:</p>
<ul>
<li>доступ к элементам массива</li>
<li>передача в функцию аргументов, которые требуется изменить</li>
<li>передача строк и массивов в функции</li>
<li>выделение памяти</li>
<li>создание сложных структрур, например, связных списков и бинарных деревьев
Вам может показаться, что большую часть операций выше можно сделать и без указателей, и мы обязательно позже рассмотрим разницу в реализации действий без указателей и с ними. Также без указателей невозможны некоторые ключывые возможности C++, такие, как операции new, виртуальные функции и тд, но об этом мы поговорим позже. Сейчас наша главная задача - разобраться с тем, что такое указатели, и как их грамотно применять.</li>
</ul>
<p>Известным фактом является то, что у каждой переменной есть свой уникальный адрес в памяти. При запуске нашей программы под нее выделяется кусок системной памяти. На рисунке 10.1 показано, как это выглядит.
<img src="images/10.1.png" alt="the memory" /></p>
<p>Давайте рассмотрим операцию получения адреса &amp; на простом примере:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
int main ( ){

int var1 = 11; // определим три переменных
int var2 = 22; // и присвоим им некоторые значения
int var3 = 33;

cout &lt;&lt; &amp;var1 &lt;&lt; endl &lt;&lt; &amp;var2 &lt;&lt; endl &lt;&lt; &amp;var3 &lt;&lt; endl; 
//выведем адреса всех трех переменных

return 0;
}
</code></pre>
<p>Вывод этой программы будет следующим:</p>
<pre><code class="language-bash">0x8f4ffff4 
0x8f4ffff2 
0x8f4ffff0 
</code></pre>
<p>Адреса, выводимые с помощью оператора  &lt;&lt;, представляются в шестнадцатеричной системе счисления</p>
<blockquote>
<p>Стоит помнить, что адрес переменной и ее значения - вещи абсолютно разные, что показано на следующей иллюстрации:
<img src="images/10.2.png" alt="adress &amp; value" /></p>
</blockquote>
<h1 id="Указатели-в-c"><a class="header" href="#Указатели-в-c">Указатели в C++</a></h1>
<blockquote>
<p>Переменная, содержащая в себе значение адреса, называется переменной-указателем или просто указателем.</p>
</blockquote>
<p>Указатель не имеет тот же тип, что и переменная, адрес которой он хранит. Проще сказать так, существует столько типов указателей, сколько существует типов данных. Есть указатели на int, на float, на char и так далее. Мы не можем иметь тип данных pointer, потому что компилятору необходимо знать, на какой именно тип данных указывает конкретный указатель. Способы создать указатели на разные типы данных:</p>
<pre><code class="language-cpp">char* cptr; // указатель на символьную переменную
int* iptr; // указатель на целую переменную
float* fptr; // указатель на вещественную переменную
Distance* distptr; // указатель на переменную класса Distance
</code></pre>
<p>Напишем простую программу, чтобы проиллюстрировать работу указателей:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    int first_var = 11;
    int second_var = 34; //создали две переменные и присвоили им значения

    std::cout &lt;&lt; &amp;first_var &lt;&lt; &quot;\n&quot; &lt;&lt; &amp;second_var &lt;&lt; &quot;\n&quot;; //вывели адреса двух переменных

    int *first_pointer = &amp;first_var; //создали указатель на int и присвоили значения адреса первой переменной
    int *second_pointer = &amp;second_var; //создали указатель на int и присвоили значения адреса второй переменной

    std::cout &lt;&lt; first_pointer &lt;&lt; &quot;\n&quot; &lt;&lt; second_pointer &lt;&lt; &quot;\n&quot;; // вывели значения двух указателей
}
</code></pre>
<pre><code class="language-bash">0x8f51fff4- адрес переменной var1 
0x8f51fff2- адрес переменной var2
0x8f51fff4- значение ptr равно адресу переменной var1 
0x8f51fff2- значение ptr равно адресу переменной var2
</code></pre>
<blockquote>
<p>Важно проверять, что перед использованием указателя ему было присвоено значения. В противном случае указатель будет хранить случайный адрес и ломать вашу программу, причем компилятор не будет на это жаловаться, а найти такую ошибку в большом коде стоит титанических усилий.</p>
</blockquote>
<h1 id="Доступ-к-переменной-по-указателю"><a class="header" href="#Доступ-к-переменной-по-указателю">Доступ к переменной по указателю</a></h1>
<p>Допустим, вы забыли имя переменной, но помните ее адрес, сможете ли вы получить значение этой переменной? Да, сможете, и в этом вам поможет указатель. Вы присвоите указателю адрес это переменной, а для доступа к значению будете использовать операцию разыменовывания. Давайте поэтапно разберемся с тем, как это будет происходить.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    int first_var = 11; //наша переменная

    int *ptr = &amp;first_var; //создали указатель на нашу переменную

    std::cout &lt;&lt;  *ptr; //вывели значние через указатель
}
</code></pre>
<p>Вывод данной программы будет содержать единственное число 11.</p>
<blockquote>
<p>Операция <code>*</code> - операция разыменовывания указателя, которая дает доступ к данным, хранящимся по адресу, на который указывает указатель. В данном случае <code>*ptr</code> - не что иное, как получение значения по адресу <code>ptr</code>. Это называется непрямым доступом или же разыменовыванием указателя.</p>
</blockquote>
<p>Указатель можно использовать не только для получения значения переменной, на которую он указывает, но и для выполнения действий с этой переменной.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    int first_var = 11;
    int second_var = 56;

    int *first_ptr = &amp;first_var; //указатель на первую переменную

    *first_ptr += 7;//увеличили данные, лежащие по адресу first_ptr на 7
    second_var = *first_ptr; //то же самое, что и second_var = first_var

    std::cout &lt;&lt; second_var; //вывели значение второй переменной
}
</code></pre>
<p>Вывод данной программы будет содержать единственное число 18.</p>
<p>Запомните, что звездочка, используемая в операции разыменования, — это не то же самое, что звездочка, используемая при объявлении указателя. Операция разыменования предшествует имени переменной и означает значение, находящееся в переменной, на которую указывает указатель. Звездочка же в объявлении указателя означает указатель на. </p>
<pre><code class="language-cpp">int* ptr; // обьявление: указатель на int
*ptr = 37; // разыменование: значение переменной, адресованной через ptr
</code></pre>
<blockquote>
<p>При присваивании одному указателю значения другого указателя важно следить, чтобы они указывали на одинаковые типы.</p>
</blockquote>
<h1 id="Обращение-к-элементам-массива-через-указатели"><a class="header" href="#Обращение-к-элементам-массива-через-указатели">Обращение к элементам массива через указатели</a></h1>
<p>Помимо обращения к элементам массива через их индексы, возможно обращение через адреса каждого из элементов.
При помощи выражения *(array + j) происходит обращение к элементу массива array с названием j. Это работает, потому что в данном случае array без квадратных скобок представляет собой адрес первого элемента массива, а <code>+ j</code> означает что элемент имеет сдвинутый на j ячеек массива от первого элемента адрес. То есть *(array + 5) берет адрес элемента, который сдвинут на 5 ячеек от адреса первого элемента массива, и производит операцию разыменовывания указателя. Таким образом через указатель мы получаем доступ к элементам массива</p>
<pre><code class="language-cpp">// доступ к элементам массива через указатель
#include &lt;iostream&gt;

int main (){

    int intarray [ 5 ] = { 31, 54, 77, 52, 93 }; // массив целых чисел

    for ( int j = 0; j &lt; 5; j++ ){ // для каждого элемента массива
        cout &lt;&lt; *( intarray + j ) &lt;&lt; &quot;\n&quot;; // напечатаем его значение, обратившись через указатель
    } 
}
</code></pre>
<p>Подробнее про работу массивами(сортировка с использованием указателей), создание строк с помощью указателей и т.д., вы можете прочитать в <a href="http://lib.jizpi.uz/pluginfile.php/7322/mod_resource/content/0/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE_%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B2_%D0%A1%2B%2B_%D0%A0_%D0%9B%D0%B0%D1%84%D0%BE%D1%80%D0%B5.pdf">книге Лафоре по плюсам</a> на страницах 424 - 471(или всю главу про указатели, начиная со страницы 411)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Память"><a class="header" href="#Память">Память</a></h1>
<blockquote>
<p><code>new int[100]</code> создаст в куче массив <code>int</code>'ов размера 100, и вернёт указатель на самый первый (нулевой) элемент.
Чтобы не было утечки памяти стоит после того, как мы закончили работать с указателем, удалить его память — сделать <code>delete pointer</code>. Сугубо говоря, <code>delete</code> вызывает <code>free</code> с нужными параметрами, а ОС освобождает память и отдаёт её в свободный пул памяти</p>
</blockquote>
<h1 id="Очистка-памяти"><a class="header" href="#Очистка-памяти">Очистка памяти</a></h1>
<!---
 https://ru.stackoverflow.com/questions/659123/%D0%9A%D0%B0%D0%BA-%D0%BE%D1%87%D0%B8%D1%81%D1%82%D0%B8%D1%82%D1%8C-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%83%D1%8E-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9
-->
<p>Если вы создаёте переменную, например, <code>string s;</code> - при выходе из области видимости будет вызван деструктор, который освободит связанные с переменной ресурсы. Фундаментальных типы, например, <code>int</code> или <code>double</code> не имеют деструкторов, но они сами удаляются.</p>
<pre><code class="language-cpp">{
  Foo f;
  // используем f
  // ...
  // здесь неявно компилятор сам вставит удаление для f
}
</code></pre>
<p>Но, у указателям надо явно удалить ресурсы, это связано из-за строения ссылок <code>c++</code>.</p>
<p>Проще говоря, все типы данных, которые <code>T</code>, а не <code>T*</code> и выделены с <code>new</code>, запустят деструкторов, а у <code>T*</code> мы должны сами запустить. </p>
<p>Для массивов — <code>delete[] arr;</code>, а для всего остального <code>delete ptr;</code></p>
<blockquote>
<p>Если не чистить память, то память может закончится. И ваше решение получит <code>ML</code> или в случае если это приложение, последствия могут быть катастрофические.</p>
</blockquote>
<h1 id="Немного-про-память"><a class="header" href="#Немного-про-память">Немного про память</a></h1>
<p>Stack (стек) выделяется память, а иногда удаляется. Так как локальные переменны, также строчки кода, куда вернуться и тп только создаются, и только последовательно как в стеке удаляются, когда их цикл жизни заканчивается. Другими словами все локальные переменные создаются последовательно в памяти, и также будут просто удалены сдвинув указатель на начало стека.</p>
<p>Heap (Куча) — это общее название места, куда вы помещаете данные, которые создаёте на лету. Если вы не знаете, сколько космических кораблей будет создавать ваша программа, вы, вероятно, будете использовать оператор <code>new</code> (или <code>malloc</code> или эквивалентный) для создания каждого космического корабля. Это распределение останется на некоторое время, поэтому, вероятно, мы будем освобождать вещи в другом порядке, чем мы их создавали.</p>
<p>Таким образом, куча намного сложнее, потому что в конечном итоге есть неиспользуемые области памяти, чередующиеся с фрагментами памяти, которые фрагментируются. Найти свободную память нужного вам размера — сложная задача. Вот почему следует избегать кучи.</p>
<p>Следует освобождать память, чтобы не получить утечку памяти.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Жадные-алгоритмы"><a class="header" href="#Жадные-алгоритмы">Жадные алгоритмы</a></h1>
<p>Возможно, вы ожидали главу о сортировках, но мы рассмотрим их применение в другом контексте.</p>
<p>Хотя сортировка является базовым алгоритмом, используемым во многих задачах, давайте сосредоточимся на жадных алгоритмах и их применении для решения задач. </p>
<p>Жадные алгоритмы могут помочь решить много задач без написания сложного кода, так как код почти всегда содержит сортировку.</p>
<p>Это особенно актуально для 	<strong>второй лабораторной работы</strong>, так как сортировка часто является базовым алгоритмом, используемым во многих задачах.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<!-- wpsh2013 p.269 
proof https://www.cs.cornell.edu/courses/cs482/2007su/exchange.pdf (step3)
-->
<p>Жадный алгоритм — это алгоритм, который на каждом шагу делает локально наилучший выбор в надежде, что итоговое решение будет оптимальным.</p>
<p>Сначала разберём базовые задачи, а затем осознаем всю мощь &quot;жадных алгоритмов&quot;.</p>
<h1 id="Задача-об-отрезках"><a class="header" href="#Задача-об-отрезках">Задача об отрезках</a></h1>
<blockquote>
<p>Даны <code>n</code> отрезков. Отрезок задаётся двумя границами — началом и концом. Вам нужно выбрать как можно больше отрезков таким образом, чтобы ни один из них не пересекался с другим.</p>
</blockquote>
<p>К решение проще приступить таким образом : нарисуйте <code>n</code> горизонтальных линей. Нарисуйте каждый отрезок на соответствующей прямой, просмотрите слева направо их. Когда вы выбираете какой-то отрезок, выделите его цветом, а все которые с ним пересекаются сотрите. Подумайте.</p>
<p>Возможно вы догадались до такой идеи — каждый раз брать отрезок у которого правая граница минимальная. Затем стирать все с ним пересекающиеся. </p>
<p>Это очевидно, по сути вы каждый раз выбираете отрезок, который стирает наименьшее количество отрезков. Но почему-бы не выбрать какой-то отрезок в центре?</p>
<p>Докажем нашу жадную стратегию <code>брать отрезки, у которых правая граница минимальная</code>. Доказывать жадный алгоритм не обязательно, но иногда <code>интуиция</code> подводит, и вы придумали не верный <code>жадный алгоритм</code> или задача вообще не решалась жадным алгоритмом.</p>
<h1 id="Доказательство"><a class="header" href="#Доказательство">Доказательство</a></h1>
<p>Пусть наше <code>жадное</code> решение выбрало множество из <code>k</code> отрезков \(A = \{(l_1, r_1), \dots, (l_k, r_k)\} \), но на самом деле оптимальное решение выбрало <code>m</code> отрезков \(B = \{(l_1, r_1), \dots, (l_m, r_m)\} \).</p>
<blockquote>
<p>Докажем, что \(k = m\). По предположению выше \(k \le m\).</p>
</blockquote>
<p>Отсортируем все отрезки \(A\) и \(B\) по возрастанию правой границы, а в случае равенства по убыванию левой. Пусть \(i\) первый индекс, где отрезки не совпадают (\(A_{i} \ne B_{i})\).</p>
<blockquote>
<p>Пусть \(i\) существует. Если нет, то прочтите текст в рамке второго случая.</p>
</blockquote>
<p>Сравним \(A_{i, r}\) и \(B_{i, r}\). </p>
<ol>
<li>
<p>Случай \(A_{i, r} &gt; B_{i, r}\) не возможен по определению нашего алгоритма. </p>
</li>
<li>
<p>Случай \(A_{i, r} &lt; B_{i, r}\). </p>
</li>
</ol>
<p>Заметим, что замена \(i\)-го отрезка в \(B\) на \(A_i\) ничего не сломает, а возможно только увеличит количество взятых отрезков. Заменим отрезок. Заметим, что можно опять заменить другие отрезки, так как <code>мы не ухудшаем</code> ответ. Пришли к тому, что \(i\) теперь не существует.</p>
<blockquote>
<p>Первые \(k\) отрезков в \(B\) совпадают со всеми из \(A\), а из этого следует, что \(k=m\), так как в противном случае, жадное решение взяло бы ещё отрезки.</p>
</blockquote>
<ol start="3">
<li>Случай \(A_{i, r} = B_{i, r}\) возможен, но доказательство для левой границы аналогично.</li>
</ol>
<blockquote>
<p>Следовательно \(k=m\) — корректность жадного решения доказана.</p>
</blockquote>
<p>Общее доказательство для любых жадных алгоритмов аналогично.</p>
<p>Код : </p>
<pre><code class="language-cpp">void solve() {
  int n;
  cin &gt;&gt; n;
  vector&lt;pair&lt;int, int&gt;&gt; a(n);
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
  }
  sort(a.begin(), a.end(), [&amp;](auto &amp;x, auto &amp;y) {
    return make_pair(x.second, -x.first) &lt; make_pair(y.second, -y.first);
  });
  int ans = 0;
  int r = INT_MIN;
  for (int i = 0; i &lt; n; i++) {
    if (r &lt; a[i].first) {
      r = a[i].second;
      ans++;
    }
  }
  cout &lt;&lt; ans;
}
</code></pre>
<h1 id="Задачи-на-которых-не-работает"><a class="header" href="#Задачи-на-которых-не-работает">Задачи на которых не работает</a></h1>
<p>Задача о размене монет (это задача о рюкзаке)</p>
<blockquote>
<p>Есть набор монет с разными номиналами, и вам нужно разменять заданную сумму минимальным количеством монет.</p>
</blockquote>
<p>Например, в нашей выдуманной стране номиналы \(3, 5, 10\). Разменять <code>5</code> можно одной <code>5</code>, <code>13</code> на две <code>3</code> и <code>10</code> и тп.</p>
<blockquote>
<p>Возможно, вы уже поняли алгоритм — выдавать сначала монету наибольшего номинала, пока можем. Потом выдаём наибольшим из оставшихся номиналов и так далее.</p>
</blockquote>
<blockquote>
<p>НО, если у нас \(1, 9, 10\) и нам надо разменять \(18\), то оптимальнее начать не с \(10\), а с \( 9 \) (<code>9 + 9 = 18</code>).</p>
</blockquote>
<blockquote>
<p>Это задача имеет достаточно простое решение — динамическое программирование. Мы рассмотрим решение такой и подобных задач немного позже.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Оценка-асимптотики-алгоритмов"><a class="header" href="#Оценка-асимптотики-алгоритмов">Оценка асимптотики алгоритмов</a></h1>
<p><a href="https://vk.com/doc191450968_561608466?hash=1K1Cd8tP7N8rZcYeFS8pSJjr82ROC22zM2WlzBbBBzz&amp;dl=RolI6VzGuZKU7zeJEYpjawEP7lZ0yWFsnsqwcJOzkIP">ССЫЛКА НА КНИГУ</a> (книга очень интересная и отлично написана, так что при наличии свободного времени рекомендуется прочитать целиком, не пожалеете)</p>
<blockquote>
<p>Каждый, кто хочет постигнуть максимально возможных результатов в изучении алгоритмов и их анализе, обязательно должен прочитать книгу Томаса Кормена.
Для изучения математических основ асимптотики, подробного разбора определений и принципов анализа алгоритмов мы предлагаем вам прочитать несколько страниц. </p>
</blockquote>
<ul>
<li>Асимптотические обозначения: страницы 87 - 97</li>
</ul>
<p>Подробнейший анализ алгоритмов:</p>
<ul>
<li>Сортировка вставкой: страницы 57 - 63</li>
<li>Анализ алгоритмов с примером оценки сортировки вставкой: страницы 64 - 71</li>
<li>Разработка нескольких алгоритмов и их анализ: страницы 71 - 86</li>
</ul>
<h1 id="Применение-в-задачах"><a class="header" href="#Применение-в-задачах">Применение в задачах</a></h1>
<p>Оценка асимптотики алгоритма позволяет прикинуть, сколько секунд решение будет работать на каком-то тесте. Для этого, достаточно посмотреть на то, что внутри <code>O()</code>, подставить туда нужные нам значения (скорее всего самые сложные по времени тесты для нашего алгоритма, это когда нам дают очень много элементов) и разделить на \(10^8 \)` и получить примерное количество секунд на выполнение.</p>
<p>Например, решение работает за \(O(n^2)\). По условию задачи \(n \le 5000\). Получаем \(5000^2 / 10^8 = 0.25\), следовательно программа в секунду уложится.</p>
<p>Это всё относительно, так как :</p>
<ol>
<li>Вы можете не верно оценивать саму асимптотику</li>
<li>Написать код, который не совсем правильно реализует алгоритм. </li>
<li>Разные операции процессор может делать с разной эффективностью. Например, операция <code>%</code> взятие по модулю работает не так быстро, как обычное деление. Так, как \(x = y % z\) для процессора эквивалентно \(x = x - y \cdot (x/y)\), а это уже три операции. Так-же компилятор может оптимизировать ваш код (и не только улучишь его асимптотику, но и ухудшить).</li>
</ol>
<p>Таблица для обычных ограничений :</p>
<table><thead><tr><th>асимптотика</th><th>максимальное n для 1-ой секунды</th></tr></thead><tbody>
<tr><td>\(O(n)\)</td><td>\(10^8\)</td></tr>
<tr><td>\(O(n \log n)\)</td><td>\(10^6\)</td></tr>
<tr><td>\(O(n^2)\)</td><td>5000</td></tr>
<tr><td>\(O(n^3)\)</td><td>1000<sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Для \(O(n^3)\) я написал 1000, так как скорее всего алгоритм использует три вложенных цикла, и компилятор <a href="https://ru.algorithmica.org/cs/arithmetic/simd/">векторизовал</a> их.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сортировки"><a class="header" href="#Сортировки">Сортировки</a></h1>
<p>Наконец-то появились сортировки! В данной главе мы с вами рассмотрим различные виды сортировок
А конкретно эту страницу допишет кто-нибудь другой, потому что уже почти 3 часа ночи, а меня хватило только на сами сортировик, сори ребят, но посмотрите их пж :(</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Пузырьковая-сортировка-bubble-sort"><a class="header" href="#Пузырьковая-сортировка-bubble-sort">&quot;Пузырьковая сортировка&quot; (Bubble sort)</a></h1>
<p>Самая простая из предложенных сортировок, представляющая собой перебор элементов массива и сравнение каждого с каждым</p>
<p>Сложность: <em><strong>O(n^2)</strong></em></p>
<blockquote>
<p>Данной сортировкой пользуются крайне редко из-за скорости её работы, поскольку при обработке массива с большим количествоми элементов время может стремиться к бесконечности
Более предпочтительными будут сортировки, представленные в других разделах этой темы</p>
</blockquote>
<h2 id="Преимущества-алгоритма"><a class="header" href="#Преимущества-алгоритма">Преимущества алгоритма</a></h2>
<ol>
<li>ну типо даже не знаю, что и сказать</li>
<li>Его знает каждый</li>
<li>Не требователен к памяти</li>
<li>Стабильный алгоритм</li>
</ol>
<h2 id="Недостатки-алгоритма"><a class="header" href="#Недостатки-алгоритма">Недостатки алгоритма</a></h2>
<ol>
<li>Сложность - O(n^2)</li>
<li>Ну типо тут и так понятно, что бабл сорт - самый крутой алгоритм, и ему нет равных</li>
</ol>
<h2 id="Обычная-версия-алгоритма"><a class="header" href="#Обычная-версия-алгоритма">Обычная версия алгоритма</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// Функция Swap меняет значения переменных местами
void swap( int *val1, int *val2 ) {
    int tmp = *val1;

    *val1 = *val2;
    *val2 = tmp;
}

// Функция &quot;пузырьковой сортировки&quot;
void bubbleSort( int *arr, int size ) {
    for (int i = 0; i &lt; size; i++) {
        for (int j = 0; j &lt; size - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                swap(&amp;arr[j], &amp;arr[j + 1]);
            }
        }
    }
}

int main( void ) {
    int size, *Array;

    std::cin &gt;&gt; size;

    Array = new int[size];           // Выделение памяти под динамический целочисленный массив размера size

    for (int i = 0; i &lt; size; i++) { // Заполнение массива Array
        std::cin &gt;&gt; Array[i];         
    }

    bubbleSort(Array, size);         // Выполнение сортировки

    for (int i = 0; i &lt; size; i++) { // Вывод отсортированного массива
        std::cout &lt;&lt; Array[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Ускоренная-версия-алгоритма"><a class="header" href="#Ускоренная-версия-алгоритма">Ускоренная версия алгоритма</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// Функция Swap меняет значения переменных местами
void swap( int *val1, int *val2 ) {
    int tmp = *val1;

    *val1 = *val2;
    *val2 = tmp;
}

// Функция &quot;пузырьковой сортировки&quot;
void bubbleSort( int *arr, int size ) {
    for (int i = 0; i &lt; size; i++) {
        bool is_any_swapped = false;

        for (int j = 0; j &lt; size - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                swap(&amp;arr[j], &amp;arr[j + 1]);
                is_any_swapped = true;
            }
        }

        // Если ни один элемент не поменялся местами с соседом, значит, что массив уже отсортирован
        if (!is_any_swapped) {
            break;
        }
    }
}

int main( void ) {
    int size, *array;

    std::cin &gt;&gt; size;

    array = new int[size];           // Выделение памяти под динамический целочисленный массив размера size

    for (int i = 0; i &lt; size; i++) { // Заполнение массива Array
        std::cin &gt;&gt; array[i];         
    }

    bubbleSort(array, size);         // Выполнение сортировки

    for (int i = 0; i &lt; size; i++) { // Вывод отсортированного массива
        std::cout &lt;&lt; array[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Пример-работы-алгоритма"><a class="header" href="#Пример-работы-алгоритма">Пример работы алгоритма</a></h2>
<p>Ввод:</p>
<pre><code class="language-bash">5
1 9 45 7 -2
</code></pre>
<p>Работа алгоритма:
Алгоритм попарно сравнивает 1 с 9, 9 с 45, 45 с 7(меняет их местами), 45 с -2(меняет их местами), а потом идёт с самого начала, но уже с обновлённым массивом</p>
<p>Вывод:</p>
<pre><code class="language-bash">-2 1 7 9 45
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сортировка-вставкой"><a class="header" href="#Сортировка-вставкой">Сортировка вставкой</a></h1>
<blockquote>
<p>Сортировка вставкой чем-то похожа игру в карты, мы добавляем элемент к чему-то уже отсортированному
Имеющийся массив надо условно разбить на отсортированную часть и неотсортированную, а потом добавлять по одному элементу к отсортированной части, <strong>вставляя</strong> его в нужное место</p>
</blockquote>
<p>Сложность: <em><strong>O(n^2)</strong></em></p>
<h2 id="Преимущества-алгоритма-1"><a class="header" href="#Преимущества-алгоритма-1">Преимущества алгоритма</a></h2>
<ol>
<li>Легкий для понимания и воспроизведения алгоритм</li>
<li>Эффективен для маленьких массивов</li>
</ol>
<h2 id="Недостатки-алгоритма-1"><a class="header" href="#Недостатки-алгоритма-1">Недостатки алгоритма</a></h2>
<ol>
<li>Сложность в среднем и худшем случаях - O(n^2)</li>
<li>Медленно работает на больших массивах</li>
</ol>
<h2 id="Реализация-алгоритма"><a class="header" href="#Реализация-алгоритма">Реализация алгоритма</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void insertionSort( int *arr, int size ) {
    int key;

    for (int i = 1; i &lt; size; i++) {
        int j = i - 1;

        key = arr[i];
 
        while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }

        arr[j + 1] = key;
    }
}

int main( void ) {
    int size, *array;

    std::cin &gt;&gt; size;

    array = new int[size];

    insertionSort(array, size);

    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; array[i] &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
<h2 id="Ввод-1"><a class="header" href="#Ввод-1">Ввод</a></h2>
<pre><code class="language-bash">6
4 1 2 5 4 -68
</code></pre>
<h2 id="Работа-алгоритма"><a class="header" href="#Работа-алгоритма">Работа алгоритма</a></h2>
<ol>
<li>Берем 4 как элемент уже отсортированного массива: { 4 }</li>
<li>Добавляем к нему 1: 1 &lt; 4, значит, ставим его до 4: { 1 4 }</li>
<li>Аналогично добавляем 2: { 1 2 4 }</li>
<li>Добавляем 5: 5 &gt; 1, 5 &gt; 2, 5 &gt; 4, значит, ставим его после 4: { 1 2 4 5 }</li>
<li>Добавляем 4: 4 &gt; 1, 4 &gt; 2, 4 &gt; 4 == false, значит, ставим его после 2 и до 4: { 1 2 4 4 5 }</li>
<li>Аналогично для -68</li>
</ol>
<h2 id="Вывод-1"><a class="header" href="#Вывод-1">Вывод</a></h2>
<pre><code class="language-bash">-68 1 2 4 4 5
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Выборочная-сортировка"><a class="header" href="#Выборочная-сортировка">&quot;Выборочная&quot; сортировка</a></h1>
<blockquote>
<p>Selection sort - простая и эффективная сортировка, которая как и Insertion sort условно делит массив на две части (отсортированную и неотсортированную), только изначально кол-во элементов в отсортированной части - 0. Далее алгоритм ищет минимамльный элемент в неотсортированной части и добавляет его в отсортированную. Данный процесс повторяется, пока все элементы не перейдут в отсортированный массив</p>
</blockquote>
<p>Сложность: <em><strong>O(n^2)</strong></em></p>
<h2 id="Преимущества-алгоритма-2"><a class="header" href="#Преимущества-алгоритма-2">Преимущества алгоритма</a></h2>
<ol>
<li>Легкий для понимания и воспроизведения</li>
<li>Хорош для маленьких массивов</li>
</ol>
<h2 id="Недостатки-алгоритма-2"><a class="header" href="#Недостатки-алгоритма-2">Недостатки алгоритма</a></h2>
<ol>
<li>Сложность O(n^2) в худшем и среднем случаях, из-за чего для больших массивов скорость работы может стремиться к бесконечности</li>
<li>Нестабильный алгоритм</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// Функция &quot;выборочной&quot; сортировки
void selectionSort( int *arr, int n ) {
    int i, j, min_ind;
 
    // Рассматривание минимального элемента в неотсортированной части и заполнение отсортировнного
    for (i = 0; i &lt; n - 1; i++) {
        // Поиск минимального элемента(его индекса)
        min_idx = i;

        for (j = i + 1; j &lt; n; j++) {
            if (arr[j] &lt; arr[min_idx]) {
                min_idx = j;
            }
        }
 
        // Замена первого элемента неотсортированного массива на его минимальный элемент
        if (min_idx != i) {
            swap(arr[min_idx], arr[i]);
        }

        // В окончании цикла совершается операция i++, которая сдвигает указатель на начало неотсортированной части массива
    }
}

int main( void ) {
    int size, *arr;

    std::cin &gt;&gt; size;
    
    arr = new int[size];

    for (int i = 0; i &lt; size; i++) {
        std::cin &gt;&gt; arr[i];
    }

    selectionSort(arr, size);
    
    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Ввод-2"><a class="header" href="#Ввод-2">Ввод:</a></h2>
<pre><code class="language-bash">5
12 865 -1233 47 2
</code></pre>
<h2 id="Работа-алгоритма-1"><a class="header" href="#Работа-алгоритма-1">Работа алгоритма</a></h2>
<p>Знак | отделяет отсортированную часть от неотсортированной
0. Изначальный массив: { | 12 865 -1233 47 2 }</p>
<ol>
<li>Ищем минимальный элемент в массиве (-1233), меняем его местами с первым элементом, итоговый массив: { -1233 | 865 12 47 2 }</li>
<li>Повторяем: { -1233 2 | 12 47 865 }</li>
<li>{ -1233 2 12 | 47 865 }</li>
<li>{ -1233 2 12 47 | 865 }</li>
<li>{ -1233 2 12 47 865 | } - Ура! Весь массив отсортирован! ПОБЕДАААААА!</li>
</ol>
<h2 id="Вывод-2"><a class="header" href="#Вывод-2">Вывод:</a></h2>
<pre><code class="language-bash">-1233 2 12 47 865
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сортировка-слиянием"><a class="header" href="#Сортировка-слиянием">Сортировка слиянием</a></h1>
<blockquote>
<p>Merge sort - рекурсивный алгоритм сортировки, разбивающий основной массив на подмассивы, сортирующий их и собирающий всё обратно в отстортированном виде</p>
</blockquote>
<p>Сложность: <em><strong>O(n log(n))</strong></em></p>
<h2 id="Преимущества-алгоритма-3"><a class="header" href="#Преимущества-алгоритма-3">Преимущества алгоритма</a></h2>
<ol>
<li>Стабильный алгоритм</li>
<li>Сложность алгоритма в худшем случае - O(n log(n)), следовательно, он хорош для больших массивов</li>
<li>Алгоритм параллелен - его можно спокойно ускорить, разбив действия на разные потоки процессора</li>
</ol>
<h2 id="Недостатки-алгоритма-3"><a class="header" href="#Недостатки-алгоритма-3">Недостатки алгоритма</a></h2>
<ol>
<li>Требователен к памяти</li>
<li>Не всегда оптимален для маленьких массивов</li>
</ol>
<h2 id="Реализация-алгоритма-1"><a class="header" href="#Реализация-алгоритма-1">Реализация алгоритма №1</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

void merge( int array, int const left, int const mid,
           int const right ) {
    int const subArrayOne = mid - left + 1;
    int const subArrayTwo = right - mid;

    // Создание временных массивов
    int *leftArray = new int[subArrayOne],
         *rightArray = new int[subArrayTwo];
 
    // Копирование данных в подмассивы
    for (auto i = 0; i &lt; subArrayOne; i++) {
        leftArray[i] = array[left + i];
    }

    for (auto j = 0; j &lt; subArrayTwo; j++) {
        rightArray[j] = array[mid + 1 + j];
    }
 
    int indexOfSubArrayOne = 0, indexOfSubArrayTwo = 0, indexOfMergedArray = left;
 
    // Соединение временных массивов в наш изначальный
    while (indexOfSubArrayOne &lt; subArrayOne
           &amp;&amp; indexOfSubArrayTwo &lt; subArrayTwo) {
        if (leftArray[indexOfSubArrayOne]
            &lt;= rightArray[indexOfSubArrayTwo]) {
            array[indexOfMergedArray]
                = leftArray[indexOfSubArrayOne];
            indexOfSubArrayOne++;
        }
        else {
            array[indexOfMergedArray]
                = rightArray[indexOfSubArrayTwo];
            indexOfSubArrayTwo++;
        }
        indexOfMergedArray++;
    }
 
    // Копирование оставшихся элементов левого ммассива, если они остались
    while (indexOfSubArrayOne &lt; subArrayOne) {
        array[indexOfMergedArray]
            = leftArray[indexOfSubArrayOne];
        indexOfSubArrayOne++;
        indexOfMergedArray++;
    }
 
    // Копирование оставшихся элементов правого ммассива, если они остались
    while (indexOfSubArrayTwo &lt; subArrayTwo) {
        array[indexOfMergedArray]
            = rightArray[indexOfSubArrayTwo];
        indexOfSubArrayTwo++;
        indexOfMergedArray++;
    }

    // Удалить массивы и очистить память
    delete[] leftArray;
    delete[] rightArray;
}
 
// begin отвечает за левый индекс, end - за правый
void mergeSort( int *array, int const begin, int const end ) {
    if (begin &gt;= end)
        return;
 
    int mid = begin + (end - begin) / 2;

    // Сортировка и соединение массива
    mergeSort(array, begin, mid);
    mergeSort(array, mid + 1, end);
    merge(array, begin, mid, end);
}
 
int main( void ) {
    int size, *arr;

    std::cin &gt;&gt; size;

    arr = new int[size];

    for (int i = 0; i &lt; size; i++) {
        std::cin &gt;&gt; arr[i];
    }

    mergeSort(arr, 0, size - 1);

    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Реализация-алгоритма-2"><a class="header" href="#Реализация-алгоритма-2">Реализация алгоритма №2</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int *B;

// Рекурсивная часть сортировки
void mergeSortRec( int *A, int size )
{
    if (size &lt; 2) {
        return;
    }

    int M = size / 2;

    // Вызов рекурсии
    mergeSortRec(A, M);
    mergeSortRec(A + M, size - M);
  
    // Копируем данный в левый и правый массивы
    for (int k = 0, i = 0, j = M; k &lt; size; ++k) {
        // Записываем меньшее значение в k-й элемент массива B
        if (j &gt;= size || i &lt; M &amp;&amp; A[i] &lt; A[j]) {
            B[k] = A[i++];
        } else {
            B[k] = A[j++];
        }
    } // Если один из массивов закончится, то просто запишется остаток другого массива
    
    // Копируем данные в исходный массив
    for (int i = 0; i &lt; size; i++) {
        A[i] = B[i];
    }
}

// Функция, вызывающая сортировку
void mergeSort( int *a, int size )
{
  B = new int[size];

  if (B == nullptr)
    return;

  mergeSortRec(a, size);

  delete[] B;
}

int main( void ) {
    int size, *arr;

    std::cin &gt;&gt; size;

    arr = new int[size];

    for (int i = 0; i &lt; size; i++) {
        std::cin &gt;&gt; arr[i];
    }

    mergeSort(arr, size);

    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Ввод-3"><a class="header" href="#Ввод-3">Ввод</a></h2>
<pre><code class="language-bash">4
49 12 -3 15
</code></pre>
<h2 id="Работа-алгоритма-2"><a class="header" href="#Работа-алгоритма-2">Работа алгоритма</a></h2>
<ol>
<li>Разбиение массива { 49 12 -3 15 } на два подмассива { 49 12 } и { -3 15 }</li>
<li>Разбиение подмассивов на части { 49 } и { 12 }, { -3 } и { 15 }</li>
<li>Сборка отсортированных подмассивов: { 12 49 } и { -3 15 }</li>
<li>Сборка массива из подмассивов: { -3 12 15 49 }</li>
</ol>
<h2 id="Вывод-3"><a class="header" href="#Вывод-3">Вывод</a></h2>
<pre><code class="language-bash">-3 12 15 49
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Быстрая-сортировка"><a class="header" href="#Быстрая-сортировка">&quot;Быстрая&quot; сортировка</a></h1>
<blockquote>
<p>Quick sort - рекурсивный алгоритм, основанный на принципе &quot;Divide and Conquer&quot; (&quot;Разделяй и властвуй&quot;). Выбирается какая-то опорная точка (pivot point), относительно которой массив разбивается на подмассивы, после чего эта точка ставится на нужное место в массив.</p>
</blockquote>
<p>Сложность: <em><strong>O(n log(n)) - лучший/средний, O(n^2) - худший</strong></em></p>
<h2 id="Преимущества-алгоритма-4"><a class="header" href="#Преимущества-алгоритма-4">Преимущества алгоритма</a></h2>
<ol>
<li>Алгоритм &quot;Разделяй и властвуй&quot; позволяющий легче решать задачу</li>
<li>Эффективен для массивов больших размеров</li>
<li>Занимает не много памяти</li>
</ol>
<h2 id="Недостатки"><a class="header" href="#Недостатки">Недостатки</a></h2>
<ol>
<li>Худшая сложность по времени - O(n^2)</li>
<li>Не лучший выбор для массивов небольших размеров</li>
<li>Нестабильная сортировка</li>
</ol>
<h2 id="Реализация-алгоритма-1-опорная-точка---1й-элемент"><a class="header" href="#Реализация-алгоритма-1-опорная-точка---1й-элемент">Реализация алгоритма №1 (опорная точка - 1й элемент)</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
// Функция Swap меняет значения переменных местами
void swap( int *val1, int *val2 ) {
    int tmp = *val1;

    *val1 = *val2;
    *val2 = tmp;
}

// Функция разделения массива
int partition( int *arr, int start, int end ) {
    int pivot = arr[start], count = 0;

    // Находим смещение опорной точки относительно начала массива
    for (int i = start + 1; i &lt;= end; i++) {
        if (arr[i] &lt;= pivot)
            count++;
    }
 
    // Ставим опорную точку в правильную позицию 
    int pivotIndex = start + count;
    swap(arr[pivotIndex], arr[start]);
 
    // Сортируем левую и правую части массива относительно опорной точки
    int i = start, j = end;
    while (i &lt; pivotIndex &amp;&amp; j &gt; pivotIndex) {
        // Проверяем, что элементы слева от опорной точки меньше
        while (arr[i] &lt;= pivot) {
            i++;
        }
        // Проверяем, что элементы справа больше
        while (arr[j] &gt; pivot) {
            j--;
        }
 
        // При необходимости меняем элемены местами
        if (i &lt; pivotIndex &amp;&amp; j &gt; pivotIndex) {
            swap(arr[i++], arr[j--]);
        }
    }
 
    return pivotIndex;
}
 
// Функция &quot;быстрой&quot; сортировки
void quickSort( int *arr, int start, int end ) {
    if (start &gt;= end)
        return;
 
    // Разделение массива
    int p = partition(arr, start, end);
 
    // Сортировка левой части
    quickSort(arr, start, p - 1);
 
    // Сортировка правой части
    quickSort(arr, p + 1, end);
}
 
int main( void ) {
    int size, *arr;

    std::cin &gt;&gt; size;

    arr = new int[size];

    for (int i = 0; i &lt; size; i++) {
        std::cin &gt;&gt; arr[i];
    }   
 
    quickSort(arr, 0, n - 1);
 
    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Реализация-алгоритма-2-опорная-точка---середина"><a class="header" href="#Реализация-алгоритма-2-опорная-точка---середина">Реализация алгоритма №2 (опорная точка - середина)</a></h2>
<pre><code class="language-cpp">#include &lt;iostream&gt;

// Функция Swap меняет значения переменных местами
void swap( int *val1, int *val2 ) {
    int tmp = *val1;

    *val1 = *val2;
    *val2 = tmp;
}

// Функция &quot;быстрой&quot; сортировки
void quickSort( int *a, int size ) {
    int b = 0, e = size - 1; // b - begin, e - end

    if (size &lt; 2)
        return;
  
    int m = a[size / 2];

    while (b &lt;= e) {
        // Проверка на то, что элементы слева - меньше, а элементы справа - больше
        while (A[b] &lt; m) {
            b++;
        }
        while (A[e] &gt; m) {
            e--;
        }

        // Если слева встретилось число большее, чем опорная точка, а справа - меньшее, меняем их местами
        if (b &lt;= e) {
            if (b != e) {
                swap(&amp;A[b], &amp;A[e]);
            }
            b++;
            e--;
        }
    }

    // Рекурсивный вызов сортировки для левой и правой частей
    quickSort(A, e + 1);
    quickSort(A + b, size - b);
}

int main( void ) {
    int size, *arr;

    std::cin &gt;&gt; size;

    arr = new int[size];

    for (int i = 0; i &lt; size; i++) {
        std::cin &gt;&gt; arr[i];
    }   
 
    quickSort(arr, 0, n - 1);
 
    for (int i = 0; i &lt; size; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';
    }
}
</code></pre>
<h2 id="Ввод-4"><a class="header" href="#Ввод-4">Ввод</a></h2>
<pre><code class="language-bash">5
9 74 -354 87 0
</code></pre>
<h2 id="Работа-алгоритма-1"><a class="header" href="#Работа-алгоритма-1">Работа алгоритма №1</a></h2>
<ol>
<li>Выбрали 9 как опорную точку, посчитали, что её индекс в итоговом массиве равен 2 - { . . 9 . . }</li>
<li>Поменяли местами 9 и -354 -- исходный массив: { -354 74 9 87 0 }</li>
<li>Разбили массив на два подмассива { -354 74 } и { 87 0 } -- исходный массив: { -354 74 9 87 0 }</li>
<li>Меняем местами элементы, не удовлетворяющие условию (слева меньше, справа больше) : { -354 0 } и { 87 74 } -- исходный массив: { -354 0 9 87 74 }</li>
<li>В каждом из подмассивов выбрали опорную точку как первый элемент (-354 и 87 соответственно)</li>
<li>Сортируем первый подмассив:
<ol>
<li>Разбили его на еще два подмассива: { } и { 0 }</li>
<li>Больше нечего разбивать :(</li>
<li>Делаем слева меньше, справа больше: { } и { 0 } -- тут не пришлось ничего менять местами -- исходный массив: { -354 0 9 87 74 }</li>
</ol>
</li>
<li>Сортируем второй подмассив:
<ol>
<li>Разбиваем его на два подмассива: { } и { 74 }</li>
<li>Больше нечего разбивать :( </li>
<li>Делаем слева меньше, справа больше: { 74 } и { } -- 74 меньше 87, поэтому поменяли местами -- исходный массив: { -354 0 9 74 87}</li>
</ol>
</li>
<li>Исходный массив отсортирован: УРААААА ПОБЕДА</li>
</ol>
<h2 id="Работа-алгоритма-2"><a class="header" href="#Работа-алгоритма-2">Работа алгоритма №2</a></h2>
<ol>
<li>Выбрали -354 как опорную точку, посчитали, ее индекс в итоговом массиве равен 0 - { -354 . . . . }</li>
<li>Поменяли местами 9 и -354 -- исходный массив: { -354 74 9 87 0 }</li>
<li>Разбили массив на два подмассива { } и { 74 9 87 0 } -- исходный массив: { -354 74 9 87 0 }</li>
<li>Меняем местами элементы, не удовлетворяющие условию (слева меньше, справа больше), всё подходит по условию, исходный массив не изменился -- исходный массив: { -354 74 9 87 0 }</li>
<li>В каждом из подмассивов выбрали опорную точку как первый элемент (ничего и 74 соответственно) </li>
<li>Первый подмассив состоит из 0 элементов, так что его не рассматриваем</li>
<li>Сортируем второй подмассив:
<ol>
<li>Разбиваем его еще на два подмассива относительно центра: { 74 } и { 87 0 }</li>
<li>Проверяем, выполняется ли условие: не выполняется, 74 &gt; 9, 0 &lt; 9. Исправляем: { 0 } { 87 74 } -- исходный массив: { -354 0 9 87 74}</li>
<li>{ 0 } нет смысла разбивать на подмассивы, а вот { 87 74 } разбиваем, получаем еще два подмассива: { } и { 74 }, работаем с ними:
<ol>
<li>Условие не выполняется, значит, 74 перекидываем влево: { 74 } и { } -- исходный массив: { -354 0 9 74 87}</li>
<li>Дальше разбивать нельзя</li>
</ol>
</li>
</ol>
</li>
<li>Массив отсортирован: УРАА ПОБЕДА</li>
</ol>
<h2 id="Вывод-4"><a class="header" href="#Вывод-4">Вывод</a></h2>
<pre><code class="language-bash">-354 0 9 74 87
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Решаем-задачи"><a class="header" href="#Решаем-задачи">Решаем задачи</a></h1>
<p>Закрепим полученные знания на задачах.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Другая-чётность"><a class="header" href="#Другая-чётность">Другая чётность</a></h1>
<p><a href="https://codeforces.com/problemset/problem/25/A">Условие задачи</a></p>
<blockquote>
<p>Модель : Найти позицию числа, чётность которого отличается от чётности всех остальных числе в массиве.</p>
</blockquote>
<h1 id="Первый-подход"><a class="header" href="#Первый-подход">Первый подход</a></h1>
<p>Поддерживать две переменные для количества чётных и нечётных элементов. По этой информации можно найти нужную нам чётность, а затем ещё раз пробежаться по массиву и вывести нужное нам число (индекс числа).</p>
<h1 id="Второй-подход"><a class="header" href="#Второй-подход">Второй подход</a></h1>
<p>Создать два массива для чётных и нечётных, в них будем хранить индексы чисел. Затем выведем первый элемент из меньшего массива.</p>
<p>Если использовать динамический массив, то я бы поступил следующем образом : </p>
<ol>
<li>Создал два массива размера <code>n</code>.</li>
<li>Создал две дополнительные переменные, для поддерживания фактического размера.</li>
<li>Сравнил две переменные (из пункта 2)</li>
<li>Вывел первый элемент нужного массива</li>
</ol>
<h1 id="Третий-подход"><a class="header" href="#Третий-подход">Третий подход</a></h1>
<p>Подсчитать сумму индексов и количество чётных и нечётных чисел. Сравнить их и вывести существующую сумму, так как сумма из одного индекса является ответом.</p>
<p>Рекомендую реализовать каждый из вариантов решения и сдать задачу.</p>
<p>О том, как сдать задачу на <a href="https://codeforces.com/">codeforces</a> можно прочитать <a href="tasks/./additional-information.html">тут</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сумма-факториалов"><a class="header" href="#Сумма-факториалов">Сумма факториалов</a></h1>
<blockquote>
<p>Вам дано число <code>n</code>, ваша задача посчитать сумму факториалов : <code>1! + 2! + 3! + ... + n!</code>. Ограничение на <code>n</code> до \(10^6\). Ответ выведите по простому модулю <code>10^9 + 7</code>.</p>
</blockquote>
<h1 id="Разбор-условия"><a class="header" href="#Разбор-условия">Разбор условия</a></h1>
<blockquote>
<p>Ответ по <code>модулю</code> часто встречается в условие для того чтобы участники могли оперировать в диапазоне целочисленных типов языка программирования. Но в большинстве случаев модулем является <code>1000000007</code> — \(10^9 + 7\). </p>
</blockquote>
<p>На самом деле, модуль используется для того, чтобы облегчить, а не усложнить вычисления. Это может показаться нелогичным, но как только вы узнаете, как работает модульная арифметика, вы поймёте, почему.</p>
<!--
https://blog.mitrichev.ch/2014/06/this-week-in-competitive-programming_11.html

https://codeforces.com/blog/entry/72527?locale=ru
-->
<blockquote>
<p><code>простой</code> модуль, так как это связано с модульной арифметикой (я сам особо не могу ответить на этот вопрос) (скоро перепишу это)</p>
</blockquote>
<h1 id="Решение-в-лоб"><a class="header" href="#Решение-в-лоб">Решение в лоб</a></h1>
<p>Факториал числа \(n \) можно посчитать за \(O(n)\) простым циклом.</p>
<p>В коде ниже используется модуль, как видите это не страшно</p>
<blockquote>
<p><code>1LL</code> это переменная <code>long long</code> равная <code>1</code>, <code>LL</code> <a href="https://en.cppreference.com/w/cpp/language/integer_literal">суффиксный литерал</a> типа. Если умножить два <code>int</code>'а между собой, то может произойти переполнение, поэтому надо считать в <code>long long</code>. При умножение <code>long long</code> на <code>int</code> получается <code>long long</code>.</p>
</blockquote>
<blockquote>
<p>По уму люди делают функции <code>add(a, b)</code> и <code>mult(a, b)</code> которые уже внутри складывают и умножают по модулю соответственно.</p>
</blockquote>
<blockquote>
<p>Очевидно, что число типа <code>long long</code> взятое по модулю <code>1e9 + 7</code> имеет диапазон \([0, 10^9 + 7)\) и влазит в <code>int</code>.</p>
</blockquote>
<pre><code class="language-cpp">int mod = 1e9 + 7;
int factorial(int n) {
  int res = 1;
  for (int i = 1; i &lt;= n; i++) {
    res = (1LL * res * i) % mod;
  }
  return res;
}
</code></pre>
<p>Тогда чтобы решить задачу, можно \(n\) раз запустить функцию <code>factorial</code> :</p>
<pre><code class="language-cpp">int sum = 0;
for (int i = 1; i &lt;= n; i++) {
	sum = (sum + factorial(i)) % mod;
}
cout &lt;&lt; sum;
</code></pre>
<p>Хочу вас расстроить, асимптотика этого решения \(O(n^2)\).</p>
<p>Подумайте, как особо ничего не переписывая сделать асимптотику \(O(n)\).</p>
<h1 id="Быстрое-решение"><a class="header" href="#Быстрое-решение">Быстрое решение</a></h1>
<p>Достаточно вспомнить определение факториала :</p>
<p>\[n! = 1 \cdot 2 \cdot 3 \cdot \dots \cdot n \]</p>
<p>Из определение следует, что</p>
<p>\[n! = (n-1)! \cdot n\]</p>
<p>Значит, для подсчёта следующего факториала, достаточно знать факториал предыдущего числа.</p>
<p>Код полного решения занимает пару строк. Рекомендую разобраться подробно в нём :</p>
<pre><code class="language-cpp">void solve() {
  int n, mod = 1e9 + 7, fac = 1, sum = 0;
  cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    fac = (1LL * fac * i) % mod;
    sum = (sum + fac) % mod;
  }
  cout &lt;&lt; sum;
}
</code></pre>
<p>Асимптотика решения \(O(n)\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Наибольший-отрезок"><a class="header" href="#Наибольший-отрезок">Наибольший отрезок</a></h1>
<blockquote>
<p>Вам дан массив длины до \(10^6\) из элементов из диапазона \( [-10^9, 10^9]\) . Найдите максимального длину отрезка массива все элементы которого не меньше \(0\).</p>
</blockquote>
<h1 id="Решение-в-лоб-1"><a class="header" href="#Решение-в-лоб-1">Решение в лоб</a></h1>
<p>Можно написать два цикла для перебора границы отрезка, а затем проверить третьим циклом все элементы в отрезке, но это будет \(O(n^3)\).</p>
<pre><code class="language-cpp">int ans = 0;
for (int l = 0; l &lt; n; l++) {
  for (int r = l; r &lt; n; r++) {
    bool ok = true;
    for (int i = l; i &lt;= r; i++) {
      if (a[i] &lt; 0) {
        ok = false;
        break;
      }
    }
    if (ok) {
      ans = max(ans, (r - l) + 1);
    }
  }
}
</code></pre>
<p>Можно чуть проще и быстрее, проверку отрезка делать параллельно.</p>
<p>Для этого достаточно понять, что в коде выше во втором цикле когда мы увеличиваем правую границу, то можно сразу проверить отрезок за \(O(1)\).</p>
<p>Напишем такой код :</p>
<pre><code class="language-cpp">int ans = 0;
for (int l = 0; l &lt; n; l++) {
  bool ok = true;
  for (int r = l; r &lt; n; r++) {
    // ...
  }
}
cout &lt;&lt; ans;
</code></pre>
<p>Подумайте немного, что можно сказать про отрезок \([l, r]\), если мы уже знаем ответ для \([l, r - 1]\). Аналогично предыдущей задачи про <a href="tasks/./sum-of-factorials.html">сумму факториалов</a>.</p>
<p>Достаточно посмотреть на <code>a[r]</code> и если он не подходит, никакие отрезки с нашей левой границей и правой границей правей нашей не будет подходить.</p>
<pre><code class="language-cpp">int ans = 0;
for (int l = 0; l &lt; n; l++) {
  bool ok = true;
  for (int r = l; r &lt; n; r++) {
    if (a[r] &lt; 0) {
      ok = false;
    }
    if (ok) {
      ans = max(ans, (r - l) + 1);
    }
  }
}
cout &lt;&lt; ans;
</code></pre>
<p>Асимптотика решения \(O(n^2)\).</p>
<h1 id="Быстрое-решение-1"><a class="header" href="#Быстрое-решение-1">Быстрое решение</a></h1>
<p>Продолжим идею решения выше. Когда <code>a[r] &lt; 0</code>, можно сделать <code>break</code>, так-же можно заметить, что если <code>a[r] &lt; 0</code>, то все отрезки с левой границей меньше <code>r</code> можно не рассматривать, так как они тоже закончатся в <code>r</code>.</p>
<blockquote>
<p>Такой подход называется два указателя. Первый указатель указывает на начало текущего отрезка, а второй на конец. Вы всего-лишь поддерживаете их в валидном состояние увеличивая в цикле.</p>
</blockquote>
<pre><code class="language-cpp">int ans = 0;
for (int l = 0; l &lt; n; l++) {
  bool ok = true;
  for (int r = l; r &lt; n; r++) {
    if (a[r] &lt; 0) {
      ok = false;
      l = r;
      break;
    }
    if (ok) {
      ans = max(ans, (r - l) + 1);
    }
  }
}
cout &lt;&lt; ans;
</code></pre>
<p>Асимптотика решения \(O(n)\).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Память-1"><a class="header" href="#Память-1">Память</a></h1>
<blockquote>
<p><code>new int[100]</code> создаст в куче массив <code>int</code>'ов размера 100, и вернёт указатель на самый первый (нулевой) элемент.
Чтобы не было утечки памяти стоит после того, как мы закончили работать с указателем, удалить его память — сделать <code>delete pointer</code>. Сугубо говоря, <code>delete</code> вызывает <code>free</code> с нужными параметрами, а ОС освобождает память и отдаёт её в свободный пул памяти</p>
</blockquote>
<h1 id="Очистка-памяти-1"><a class="header" href="#Очистка-памяти-1">Очистка памяти</a></h1>
<!---
 https://ru.stackoverflow.com/questions/659123/%D0%9A%D0%B0%D0%BA-%D0%BE%D1%87%D0%B8%D1%81%D1%82%D0%B8%D1%82%D1%8C-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C-%D0%B2%D1%8B%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%83%D1%8E-%D0%B4%D0%BB%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B9
-->
<p>Если вы создаёте переменную, например, <code>string s;</code> - при выходе из области видимости будет вызван деструктор, который освободит связанные с переменной ресурсы. Фундаментальных типы, например, <code>int</code> или <code>double</code> не имеют деструкторов, но они сами удаляются.</p>
<pre><code class="language-cpp">{
  Foo f;
  // используем f
  // ...
  // здесь неявно компилятор сам вставит удаление для f
}
</code></pre>
<p>Но, у указателям надо явно удалить ресурсы, это связано из-за строения ссылок <code>c++</code>.</p>
<p>Проще говоря, все типы данных, которые <code>T</code>, а не <code>T*</code> и выделены с <code>new</code>, запустят деструкторов, а у <code>T*</code> мы должны сами запустить. </p>
<p>Для массивов — <code>delete[] arr;</code>, а для всего остального <code>delete ptr;</code></p>
<blockquote>
<p>Если не чистить память, то память может закончится. И ваше решение получит <code>ML</code> или в случае если это приложение, последствия могут быть катастрофические.</p>
</blockquote>
<h1 id="Немного-про-память-1"><a class="header" href="#Немного-про-память-1">Немного про память</a></h1>
<p>Stack (стек) выделяется память, а иногда удаляется. Так как локальные переменны, также строчки кода, куда вернуться и тп только создаются, и только последовательно как в стеке удаляются, когда их цикл жизни заканчивается. Другими словами все локальные переменные создаются последовательно в памяти, и также будут просто удалены сдвинув указатель на начало стека.</p>
<p>Heap (Куча) — это общее название места, куда вы помещаете данные, которые создаёте на лету. Если вы не знаете, сколько космических кораблей будет создавать ваша программа, вы, вероятно, будете использовать оператор <code>new</code> (или <code>malloc</code> или эквивалентный) для создания каждого космического корабля. Это распределение останется на некоторое время, поэтому, вероятно, мы будем освобождать вещи в другом порядке, чем мы их создавали.</p>
<p>Таким образом, куча намного сложнее, потому что в конечном итоге есть неиспользуемые области памяти, чередующиеся с фрагментами памяти, которые фрагментируются. Найти свободную память нужного вам размера — сложная задача. Вот почему следует избегать кучи.</p>
<p>Следует освобождать память, чтобы не получить утечку памяти.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сделайте-вклад"><a class="header" href="#Сделайте-вклад">Сделайте вклад</a></h1>
<p>Будем признательны за любой вклад.</p>
<ul>
<li>Нам нужны люди в команду, которые будут читать тексты (которые пишутся) и помогать с проектом. </li>
<li>Проходите опросы в канале</li>
<li>Зайдите в чат канала и задавайте свои вопросы (или мне в личку)</li>
<li>Проект находится, на <a href="https://github.com/9kin/is-algo/tree/master/">гитхабе</a>, пул-реквесты приветствуются.</li>
</ul>
<h1 id="Как-работать-с-репозиторием"><a class="header" href="#Как-работать-с-репозиторием">Как работать с репозиторием</a></h1>
<ol>
<li>Клонируйте репозиторий</li>
<li>Установите <code>mdbook</code> (сборка сайта по файлам). (заранее установите <code>Rust</code>)</li>
<li>Запустите <code>mdbook serve</code> и сайт соберётся. </li>
<li>Сделайте изменения</li>
<li>Запушьте изменения в свой репозиторий.</li>
<li>Создайте <a href="https://github.com/9kin/is-algo">PR</a>.</li>
<li>Наша команда скорее всего примет ваши изменения.</li>
</ol>
<p>Рекомендуется перед созданием PR пройтись спеллчекером (например, <code>hunspell</code>-ом или <a href="https://github.com/hcodes/yaspeller"><code>yaspeller</code></a>-ом).</p>
<p>Для <code>yaspeller</code>-а у нашего проекта есть дополнительный набор специальных терминов на 500 различных слов. И различные правила.</p>
<ol>
<li>Установка <code>npm install yaspeller -g</code>.</li>
<li>Запуск из корня проекта <code>yaspeller [dir of file]</code>.</li>
</ol>
<p>Конфиг <code>yaspeller</code>-а лежит в корне проекта, добавляйте новые слова.</p>
<p><a href="https://github.com/9kin/algorithmica/commit/4d66459b074afb3831cca0aa7e330c5a285cd064#diff-d8a94d4affe0f4f5d2bb269eeab83306c4db42b90d3b220e4636cc71590041b1">TODO</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
                
    </body>
</html>
